/**
 * Highstock JS v11.3.0 (2024-01-10)
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2024 Pawel Fus, Sebastian Bochan
 *
 * License: www.highcharts.com/license
 */!function(t){"object"==typeof module&&module.exports?(t.default=t,module.exports=t):"function"==typeof define&&define.amd?define("highcharts/indicators/indicators",["highcharts","highcharts/modules/stock"],function(e){return t(e),t.Highcharts=e,t}):t("undefined"!=typeof Highcharts?Highcharts:void 0)}(function(t){"use strict";var e=t?t._modules:{};function a(t,e,a,i){t.hasOwnProperty(e)||(t[e]=i.apply(null,a),"function"==typeof CustomEvent&&window.dispatchEvent(new CustomEvent("HighchartsModuleLoaded",{detail:{path:e,module:t[e]}})))}a(e,"Stock/Indicators/SMA/SMAIndicator.js",[e["Core/Chart/Chart.js"],e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e,a){let{line:i}=e.seriesTypes,{addEvent:s,fireEvent:n,error:o,extend:r,isArray:l,merge:h,pick:d,splat:u}=a;class c extends i{destroy(){this.dataEventsToUnbind.forEach(function(t){t()}),super.destroy.apply(this,arguments)}getName(){let t=[],e=this.name;return e||((this.nameComponents||[]).forEach(function(e,a){t.push(this.options.params[e]+d(this.nameSuffixes[a],""))},this),e=(this.nameBase||this.type.toUpperCase())+(this.nameComponents?" ("+t.join(", ")+")":"")),e}getValues(t,e){let a=e.period,i=t.xData,s=t.yData,n=s.length,o=[],r=[],h=[],d,u=-1,c=0,p,f=0;if(!(i.length<a)){for(l(s[0])&&(u=e.index?e.index:0);c<a-1;)f+=u<0?s[c]:s[c][u],c++;for(d=c;d<n;d++)f+=u<0?s[d]:s[d][u],p=[i[d],f/a],o.push(p),r.push(p[0]),h.push(p[1]),f-=u<0?s[d-c]:s[d-c][u];return{values:o,xData:r,yData:h}}}init(e,a){let i=this;super.init.call(i,e,a);let n=s(t,"afterLinkSeries",function({isUpdating:t}){if(t)return;let a=!!i.dataEventsToUnbind.length;if(!i.linkedParent)return o("Series "+i.options.linkedTo+" not found! Check `linkedTo`.",!1,e);if(!a&&(i.dataEventsToUnbind.push(s(i.linkedParent,"updatedData",function(){i.recalculateValues()})),i.calculateOn.xAxis&&i.dataEventsToUnbind.push(s(i.linkedParent.xAxis,i.calculateOn.xAxis,function(){i.recalculateValues()}))),"init"===i.calculateOn.chart)i.processedYData||i.recalculateValues();else if(!a){let t=s(i.chart,i.calculateOn.chart,function(){i.recalculateValues(),t()})}},{order:0});i.dataEventsToUnbind=[],i.eventsToUnbind.push(n)}recalculateValues(){let t=[],e=this.points||[],a=(this.xData||[]).length,i=!0,s,o,r,l,h,d,c=this.linkedParent.options&&this.linkedParent.yData&&this.linkedParent.yData.length&&this.getValues(this.linkedParent,this.options.params)||{values:[],xData:[],yData:[]};if(a&&!this.hasGroupedData&&this.visible&&this.points){if(this.cropped){for(this.xAxis&&(l=this.xAxis.min,h=this.xAxis.max),r=this.cropData(c.xData,c.yData,l,h),d=0;d<r.xData.length;d++)t.push([r.xData[d]].concat(u(r.yData[d])));s=c.xData.indexOf(this.xData[0]),o=c.xData.indexOf(this.xData[this.xData.length-1]),-1===s&&o===c.xData.length-2&&t[0][0]===e[0].x&&t.shift(),this.updateData(t)}else(this.updateAllPoints||c.xData.length!==a-1&&c.xData.length!==a+1)&&(i=!1,this.updateData(c.values))}i&&(this.xData=c.xData,this.yData=c.yData,this.options.data=c.values),this.calculateOn.xAxis&&this.processedXData&&(delete this.processedXData,this.isDirty=!0,this.redraw()),this.isDirtyData=!!this.linkedSeries.length,n(this,"updatedData")}processData(){let t=this.options.compareToMain,e=this.linkedParent;super.processData.apply(this,arguments),this.dataModify&&e&&e.dataModify&&e.dataModify.compareValue&&t&&(this.dataModify.compareValue=e.dataModify.compareValue)}}return c.defaultOptions=h(i.defaultOptions,{name:void 0,tooltip:{valueDecimals:4},linkedTo:void 0,compareToMain:!1,params:{index:3,period:14}}),r(c.prototype,{calculateOn:{chart:"init"},hasDerivedData:!0,nameComponents:["period"],nameSuffixes:[],useCommonDataGrouping:!0}),e.registerSeriesType("sma",c),c}),a(e,"Stock/Indicators/EMA/EMAIndicator.js",[e["Core/Series/SeriesRegistry.js"],e["Core/Utilities.js"]],function(t,e){let{sma:a}=t.seriesTypes,{correctFloat:i,isArray:s,merge:n}=e;class o extends a{accumulatePeriodPoints(t,e,a){let i=0,s=0;for(;s<t;)i+=e<0?a[s]:a[s][e],s++;return i}calculateEma(t,e,a,s,n,o,r){let l=t[a-1],h=o<0?e[a-1]:e[a-1][o],d=void 0===n?r:i(h*s+n*(1-s));return[l,d]}getValues(t,e){let a=e.period,i=t.xData,n=t.yData,o=n?n.length:0,r=2/(a+1),l=[],h=[],d=[],u,c,p,f=-1,x=0;if(!(o<a)){for(s(n[0])&&(f=e.index?e.index:0),x=this.accumulatePeriodPoints(a,f,n)/a,p=a;p<o+1;p++)c=this.calculateEma(i,n,p,r,u,f,x),l.push(c),h.push(c[0]),d.push(c[1]),u=c[1];return{values:l,xData:h,yData:d}}}}return o.defaultOptions=n(a.defaultOptions,{params:{index:3,period:9}}),t.registerSeriesType("ema",o),o}),a(e,"masters/indicators/indicators.src.js",[],function(){})});