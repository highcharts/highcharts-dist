!/**
 * Highstock JS v12.5.0 (2026-01-12)
 * @module highcharts/indicators/stochastic
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2026 Highsoft AS
 * Author: Paweł Fus
 *
 * A commercial license may be required depending on use.
 * See www.highcharts.com/license
 */function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts,t._Highcharts.SeriesRegistry):"function"==typeof define&&define.amd?define("highcharts/indicators/stochastic",["highcharts/highcharts"],function(t){return e(t,t.SeriesRegistry)}):"object"==typeof exports?exports["highcharts/indicators/stochastic"]=e(t._Highcharts,t._Highcharts.SeriesRegistry):t.Highcharts=e(t.Highcharts,t.Highcharts.SeriesRegistry)}("u"<typeof window?this:window,(t,e)=>(()=>{"use strict";var i,o={512:t=>{t.exports=e},944:e=>{e.exports=t}},r={};function a(t){var e=r[t];if(void 0!==e)return e.exports;var i=r[t]={exports:{}};return o[t](i,i.exports,a),i.exports}a.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},a.d=(t,e)=>{for(var i in e)a.o(e,i)&&!a.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var s={};a.d(s,{default:()=>v});var n=a(944),p=a.n(n);let l=function(t,e,i){return t.reduce((t,o)=>[Math.min(t[0],o[e]),Math.max(t[1],o[i])],[Number.MAX_VALUE,-Number.MAX_VALUE])};var h=a(512),c=a.n(h);let{sma:{prototype:u}}=c().seriesTypes,{defined:d,error:f,merge:y}=p();!function(t){let e=["bottomLine"],i=["top","bottom"],o=["top"];function r(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function a(t,e){let i=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&i.push(r(t))}),i}function s(){let t=this,e=t.pointValKey,i=t.linesApiNames,o=t.areaLinesNames,s=t.points,n=t.options,p=t.graph,l={options:{gapSize:n.gapSize}},h=[],c=a(t,e),g=s.length,m;if(c.forEach((t,e)=>{for(h[e]=[];g--;)m=s[g],h[e].push({x:m.x,plotX:m.plotX,plotY:m[t],isNull:!d(m[t])});g=s.length}),t.userOptions.fillColor&&o.length){let e=h[c.indexOf(r(o[0]))],i=1===o.length?s:h[c.indexOf(r(o[1]))],a=t.color;t.points=i,t.nextPoints=e,t.color=t.userOptions.fillColor,t.options=y(s,l),t.graph=t.area,t.fillGraph=!0,u.drawGraph.call(t),t.area=t.graph,delete t.nextPoints,delete t.fillGraph,t.color=a}i.forEach((e,i)=>{h[i]?(t.points=h[i],n[e]?t.options=y(n[e].styles,l):f('Error: "There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),t.graph=t["graph"+e],u.drawGraph.call(t),t["graph"+e]=t.graph):f('Error: "'+e+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),t.points=s,t.options=n,t.graph=p,u.drawGraph.call(t)}function n(t){let e,i=[],o=[];if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=u.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",i=u.getGraphPath.call(this,t),o=e.slice(0,i.length);for(let t=o.length-1;t>=0;t--)i.push(o[t])}}else i=u.getGraphPath.apply(this,arguments);return i}function p(t){let e=[];return(this.pointArrayMap||[]).forEach(i=>{e.push(t[i])}),e}function l(){let t=this.pointArrayMap,e=[],i;e=a(this),u.translate.apply(this,arguments),this.points.forEach(o=>{t.forEach((t,r)=>{i=o[t],this.dataModify&&(i=this.dataModify.modifyValue(i)),null!==i&&(o[e[r]]=this.yAxis.toPixels(i,!0))})})}t.compose=function(t){let r=t.prototype;return r.linesApiNames=r.linesApiNames||e.slice(),r.pointArrayMap=r.pointArrayMap||i.slice(),r.pointValKey=r.pointValKey||"top",r.areaLinesNames=r.areaLinesNames||o.slice(),r.drawGraph=s,r.getGraphPath=n,r.toYData=p,r.translate=l,t}}(i||(i={}));let g=i,{sma:m}=c().seriesTypes,{extend:x,isArray:A,merge:N}=p();class b extends m{init(){super.init.apply(this,arguments),this.options=N({smoothedLine:{styles:{lineColor:this.color}}},this.options)}getValues(t,e){let i=e.periods[0],o=e.periods[1],r=t.xData,a=t.yData,s=a?a.length:0,n=[],p=[],h=[],c,u,d=null,f,y;if(s<i||!A(a[0])||4!==a[0].length)return;let g=!0,m=0;for(y=i-1;y<s;y++){if(c=(f=l(a.slice(y-i+1,y+1),2,1))[0],isNaN(u=(a[y][3]-c)/(f[1]-c)*100)&&g){m++;continue}g&&!isNaN(u)&&(g=!1);let t=p.push(r[y]);isNaN(u)?h.push([h[t-2]&&"number"==typeof h[t-2][0]?h[t-2][0]:null,null]):h.push([u,null]),y>=m+(i-1)+(o-1)&&(d=super.getValues({xData:p.slice(-o),yData:h.slice(-o)},{period:o}).yData[0]),n.push([r[y],u,d]),h[t-1][1]=d}return{values:n,xData:p,yData:h}}}b.defaultOptions=N(m.defaultOptions,{params:{index:void 0,period:void 0,periods:[14,3]},marker:{enabled:!1},tooltip:{pointFormat:'<span style="color:{point.color}">●</span><b> {series.name}</b><br/>%K: {point.y}<br/>%D: {point.smoothed}<br/>'},smoothedLine:{styles:{lineWidth:1,lineColor:void 0}},dataGrouping:{approximation:"averages"}}),x(b.prototype,{areaLinesNames:[],nameComponents:["periods"],nameBase:"Stochastic",pointArrayMap:["y","smoothed"],parallelArrays:["x","y","smoothed"],pointValKey:"y",linesApiNames:["smoothedLine"]}),g.compose(b),c().registerSeriesType("stochastic",b);let v=p();return s.default})());