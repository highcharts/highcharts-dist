{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Boost module\n *\n * (c) 2010-2021 Highsoft AS\n * Author: Torstein Honsi\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/boost-canvas', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Extensions/Boost/Boostables.js', [], function () {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        // These are the series we allow boosting for.\n        const Boostables = [\n            'area',\n            'areaspline',\n            'arearange',\n            'column',\n            'columnrange',\n            'bar',\n            'line',\n            'scatter',\n            'heatmap',\n            'bubble',\n            'treemap'\n        ];\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return Boostables;\n    });\n    _registerModule(_modules, 'Extensions/Boost/BoostableMap.js', [_modules['Extensions/Boost/Boostables.js']], function (Boostables) {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Imports\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        // These are the series we allow boosting for.\n        const BoostableMap = {};\n        Boostables.forEach((item) => {\n            BoostableMap[item] = true;\n        });\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BoostableMap;\n    });\n    _registerModule(_modules, 'Extensions/Boost/BoostChart.js', [_modules['Extensions/Boost/BoostableMap.js'], _modules['Core/Utilities.js']], function (BoostableMap, U) {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { addEvent, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const composedClasses = [];\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function compose(ChartClass, wglMode) {\n            if (wglMode && U.pushUnique(composedClasses, ChartClass)) {\n                ChartClass.prototype.callbacks.push(onChartCallback);\n            }\n            return ChartClass;\n        }\n        /**\n         * Get the clip rectangle for a target, either a series or the chart.\n         * For the chart, we need to consider the maximum extent of its Y axes,\n         * in case of Highcharts Stock panes and navigator.\n         *\n         * @private\n         * @function Highcharts.Chart#getBoostClipRect\n         */\n        function getBoostClipRect(chart, target) {\n            let clipBox = {\n                x: chart.plotLeft,\n                y: chart.plotTop,\n                width: chart.plotWidth,\n                height: chart.navigator ? // #17820\n                    chart.navigator.top + chart.navigator.height - chart.plotTop :\n                    chart.plotHeight\n            };\n            // Clipping of individal series (#11906, #19039).\n            if (target.getClipBox) {\n                const { xAxis, yAxis } = target;\n                clipBox = target.getClipBox();\n                if (chart.inverted) {\n                    const lateral = clipBox.width;\n                    clipBox.width = clipBox.height;\n                    clipBox.height = lateral;\n                    clipBox.x = yAxis.pos;\n                    clipBox.y = xAxis.pos;\n                }\n                else {\n                    clipBox.x = xAxis.pos;\n                    clipBox.y = yAxis.pos;\n                }\n            }\n            if (target === chart) {\n                const verticalAxes = chart.inverted ? chart.xAxis : chart.yAxis; // #14444\n                if (verticalAxes.length <= 1) {\n                    clipBox.y = Math.min(verticalAxes[0].pos, clipBox.y);\n                    clipBox.height = (verticalAxes[0].pos -\n                        chart.plotTop +\n                        verticalAxes[0].len);\n                }\n            }\n            return clipBox;\n        }\n        /**\n         * Returns true if the chart is in series boost mode.\n         * @private\n         * @param {Highcharts.Chart} chart\n         * Chart to check.\n         * @return {boolean}\n         * `true` if the chart is in series boost mode.\n         */\n        function isChartSeriesBoosting(chart) {\n            const allSeries = chart.series, boost = chart.boost = chart.boost || {}, boostOptions = chart.options.boost || {}, threshold = pick(boostOptions.seriesThreshold, 50);\n            if (allSeries.length >= threshold) {\n                return true;\n            }\n            if (allSeries.length === 1) {\n                return false;\n            }\n            let allowBoostForce = boostOptions.allowForce;\n            if (typeof allowBoostForce === 'undefined') {\n                allowBoostForce = true;\n                for (const axis of chart.xAxis) {\n                    if (pick(axis.min, -Infinity) > pick(axis.dataMin, -Infinity) ||\n                        pick(axis.max, Infinity) < pick(axis.dataMax, Infinity)) {\n                        allowBoostForce = false;\n                        break;\n                    }\n                }\n            }\n            if (typeof boost.forceChartBoost !== 'undefined') {\n                if (allowBoostForce) {\n                    return boost.forceChartBoost;\n                }\n                boost.forceChartBoost = void 0;\n            }\n            // If there are more than five series currently boosting,\n            // we should boost the whole chart to avoid running out of webgl contexts.\n            let canBoostCount = 0, needBoostCount = 0, seriesOptions;\n            for (const series of allSeries) {\n                seriesOptions = series.options;\n                // Don't count series with boostThreshold set to 0\n                // See #8950\n                // Also don't count if the series is hidden.\n                // See #9046\n                if (seriesOptions.boostThreshold === 0 ||\n                    series.visible === false) {\n                    continue;\n                }\n                // Don't count heatmap series as they are handled differently.\n                // In the future we should make the heatmap/treemap path compatible\n                // with forcing. See #9636.\n                if (series.type === 'heatmap') {\n                    continue;\n                }\n                if (BoostableMap[series.type]) {\n                    ++canBoostCount;\n                }\n                if (patientMax(series.processedXData, seriesOptions.data, \n                // series.xData,\n                series.points) >= (seriesOptions.boostThreshold || Number.MAX_VALUE)) {\n                    ++needBoostCount;\n                }\n            }\n            boost.forceChartBoost = allowBoostForce && ((\n            // Even when the series that need a boost are less than or equal\n            // to 5, force a chart boost when all series are to be boosted.\n            // See #18815\n            canBoostCount === allSeries.length &&\n                needBoostCount === canBoostCount) ||\n                needBoostCount > 5);\n            return boost.forceChartBoost;\n        }\n        /**\n         * Take care of the canvas blitting\n         * @private\n         */\n        function onChartCallback(chart) {\n            /**\n             * Convert chart-level canvas to image.\n             * @private\n             */\n            function canvasToSVG() {\n                if (chart.boost &&\n                    chart.boost.wgl &&\n                    isChartSeriesBoosting(chart)) {\n                    chart.boost.wgl.render(chart);\n                }\n            }\n            /**\n             * Clear chart-level canvas.\n             * @private\n             */\n            function preRender() {\n                // Reset force state\n                chart.boost = chart.boost || {};\n                chart.boost.forceChartBoost = void 0;\n                chart.boosted = false;\n                // Clear the canvas\n                if (chart.boost.clear) {\n                    chart.boost.clear();\n                }\n                if (chart.boost.canvas &&\n                    chart.boost.wgl &&\n                    isChartSeriesBoosting(chart)) {\n                    // Allocate\n                    chart.boost.wgl.allocateBuffer(chart);\n                }\n                // see #6518 + #6739\n                if (chart.boost.markerGroup &&\n                    chart.xAxis &&\n                    chart.xAxis.length > 0 &&\n                    chart.yAxis &&\n                    chart.yAxis.length > 0) {\n                    chart.boost.markerGroup.translate(chart.xAxis[0].pos, chart.yAxis[0].pos);\n                }\n            }\n            addEvent(chart, 'predraw', preRender);\n            addEvent(chart, 'render', canvasToSVG);\n            // addEvent(chart, 'zoom', function () {\n            //     chart.boostForceChartBoost =\n            //         shouldForceChartSeriesBoosting(chart);\n            // });\n            let prevX = -1;\n            let prevY = -1;\n            addEvent(chart.pointer, 'afterGetHoverData', () => {\n                const series = chart.hoverSeries;\n                chart.boost = chart.boost || {};\n                if (chart.boost.markerGroup && series) {\n                    const xAxis = chart.inverted ? series.yAxis : series.xAxis;\n                    const yAxis = chart.inverted ? series.xAxis : series.yAxis;\n                    if ((xAxis && xAxis.pos !== prevX) ||\n                        (yAxis && yAxis.pos !== prevY)) {\n                        // #10464: Keep the marker group position in sync with the\n                        // position of the hovered series axes since there is only\n                        // one shared marker group when boosting.\n                        chart.boost.markerGroup.translate(xAxis.pos, yAxis.pos);\n                        prevX = xAxis.pos;\n                        prevY = yAxis.pos;\n                    }\n                }\n            });\n        }\n        /**\n         * Tolerant max() function.\n         *\n         * @private\n         * @param {...Array<Array<unknown>>} args\n         * Max arguments\n         * @return {number}\n         * Max value\n         */\n        function patientMax(...args) {\n            let r = -Number.MAX_VALUE;\n            args.forEach(function (t) {\n                if (typeof t !== 'undefined' &&\n                    t !== null &&\n                    typeof t.length !== 'undefined') {\n                    // r = r < t.length ? t.length : r;\n                    if (t.length > 0) {\n                        r = t.length;\n                        return true;\n                    }\n                }\n            });\n            return r;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const BoostChart = {\n            compose,\n            getBoostClipRect,\n            isChartSeriesBoosting\n        };\n\n        return BoostChart;\n    });\n    _registerModule(_modules, 'Extensions/Boost/WGLDrawMode.js', [], function () {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const WGLDrawMode = {\n            'area': 'LINES',\n            'arearange': 'LINES',\n            'areaspline': 'LINES',\n            'column': 'LINES',\n            'columnrange': 'LINES',\n            'bar': 'LINES',\n            'line': 'LINE_STRIP',\n            'scatter': 'POINTS',\n            'heatmap': 'TRIANGLES',\n            'treemap': 'TRIANGLES',\n            'bubble': 'POINTS'\n        };\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WGLDrawMode;\n    });\n    _registerModule(_modules, 'Extensions/Boost/WGLShader.js', [_modules['Core/Utilities.js']], function (U) {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { clamp, error, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const fragmentShader = [\n            /* eslint-disable max-len, @typescript-eslint/indent */\n            'precision highp float;',\n            'uniform vec4 fillColor;',\n            'varying highp vec2 position;',\n            'varying highp vec4 vColor;',\n            'uniform sampler2D uSampler;',\n            'uniform bool isCircle;',\n            'uniform bool hasColor;',\n            // 'vec4 toColor(float value, vec2 point) {',\n            //     'return vec4(0.0, 0.0, 0.0, 0.0);',\n            // '}',\n            'void main(void) {',\n            'vec4 col = fillColor;',\n            'vec4 tcol = texture2D(uSampler, gl_PointCoord.st);',\n            'if (hasColor) {',\n            'col = vColor;',\n            '}',\n            'if (isCircle) {',\n            'col *= tcol;',\n            'if (tcol.r < 0.0) {',\n            'discard;',\n            '} else {',\n            'gl_FragColor = col;',\n            '}',\n            '} else {',\n            'gl_FragColor = col;',\n            '}',\n            '}'\n            /* eslint-enable max-len, @typescript-eslint/indent */\n        ].join('\\n');\n        const vertexShader = [\n            /* eslint-disable max-len, @typescript-eslint/indent */\n            '#version 100',\n            '#define LN10 2.302585092994046',\n            'precision highp float;',\n            'attribute vec4 aVertexPosition;',\n            'attribute vec4 aColor;',\n            'varying highp vec2 position;',\n            'varying highp vec4 vColor;',\n            'uniform mat4 uPMatrix;',\n            'uniform float pSize;',\n            'uniform float translatedThreshold;',\n            'uniform bool hasThreshold;',\n            'uniform bool skipTranslation;',\n            'uniform float xAxisTrans;',\n            'uniform float xAxisMin;',\n            'uniform float xAxisMinPad;',\n            'uniform float xAxisPointRange;',\n            'uniform float xAxisLen;',\n            'uniform bool  xAxisPostTranslate;',\n            'uniform float xAxisOrdinalSlope;',\n            'uniform float xAxisOrdinalOffset;',\n            'uniform float xAxisPos;',\n            'uniform bool  xAxisCVSCoord;',\n            'uniform bool  xAxisIsLog;',\n            'uniform bool  xAxisReversed;',\n            'uniform float yAxisTrans;',\n            'uniform float yAxisMin;',\n            'uniform float yAxisMinPad;',\n            'uniform float yAxisPointRange;',\n            'uniform float yAxisLen;',\n            'uniform bool  yAxisPostTranslate;',\n            'uniform float yAxisOrdinalSlope;',\n            'uniform float yAxisOrdinalOffset;',\n            'uniform float yAxisPos;',\n            'uniform bool  yAxisCVSCoord;',\n            'uniform bool  yAxisIsLog;',\n            'uniform bool  yAxisReversed;',\n            'uniform bool  isBubble;',\n            'uniform bool  bubbleSizeByArea;',\n            'uniform float bubbleZMin;',\n            'uniform float bubbleZMax;',\n            'uniform float bubbleZThreshold;',\n            'uniform float bubbleMinSize;',\n            'uniform float bubbleMaxSize;',\n            'uniform bool  bubbleSizeAbs;',\n            'uniform bool  isInverted;',\n            'float bubbleRadius(){',\n            'float value = aVertexPosition.w;',\n            'float zMax = bubbleZMax;',\n            'float zMin = bubbleZMin;',\n            'float radius = 0.0;',\n            'float pos = 0.0;',\n            'float zRange = zMax - zMin;',\n            'if (bubbleSizeAbs){',\n            'value = value - bubbleZThreshold;',\n            'zMax = max(zMax - bubbleZThreshold, zMin - bubbleZThreshold);',\n            'zMin = 0.0;',\n            '}',\n            'if (value < zMin){',\n            'radius = bubbleZMin / 2.0 - 1.0;',\n            '} else {',\n            'pos = zRange > 0.0 ? (value - zMin) / zRange : 0.5;',\n            'if (bubbleSizeByArea && pos > 0.0){',\n            'pos = sqrt(pos);',\n            '}',\n            'radius = ceil(bubbleMinSize + pos * (bubbleMaxSize - bubbleMinSize)) / 2.0;',\n            '}',\n            'return radius * 2.0;',\n            '}',\n            'float translate(float val,',\n            'float pointPlacement,',\n            'float localA,',\n            'float localMin,',\n            'float minPixelPadding,',\n            'float pointRange,',\n            'float len,',\n            'bool  cvsCoord,',\n            'bool  isLog,',\n            'bool  reversed',\n            '){',\n            'float sign = 1.0;',\n            'float cvsOffset = 0.0;',\n            'if (cvsCoord) {',\n            'sign *= -1.0;',\n            'cvsOffset = len;',\n            '}',\n            'if (isLog) {',\n            'val = log(val) / LN10;',\n            '}',\n            'if (reversed) {',\n            'sign *= -1.0;',\n            'cvsOffset -= sign * len;',\n            '}',\n            'return sign * (val - localMin) * localA + cvsOffset + ',\n            '(sign * minPixelPadding);',\n            '}',\n            'float xToPixels(float value) {',\n            'if (skipTranslation){',\n            'return value;// + xAxisPos;',\n            '}',\n            'return translate(value, 0.0, xAxisTrans, xAxisMin, xAxisMinPad, xAxisPointRange, xAxisLen, xAxisCVSCoord, xAxisIsLog, xAxisReversed);// + xAxisPos;',\n            '}',\n            'float yToPixels(float value, float checkTreshold) {',\n            'float v;',\n            'if (skipTranslation){',\n            'v = value;// + yAxisPos;',\n            '} else {',\n            'v = translate(value, 0.0, yAxisTrans, yAxisMin, yAxisMinPad, yAxisPointRange, yAxisLen, yAxisCVSCoord, yAxisIsLog, yAxisReversed);// + yAxisPos;',\n            'if (v > yAxisLen) {',\n            'v = yAxisLen;',\n            '}',\n            '}',\n            'if (checkTreshold > 0.0 && hasThreshold) {',\n            'v = min(v, translatedThreshold);',\n            '}',\n            'return v;',\n            '}',\n            'void main(void) {',\n            'if (isBubble){',\n            'gl_PointSize = bubbleRadius();',\n            '} else {',\n            'gl_PointSize = pSize;',\n            '}',\n            // 'gl_PointSize = 10.0;',\n            'vColor = aColor;',\n            'if (skipTranslation && isInverted) {',\n            // If we get translated values from JS, just swap them (x, y)\n            'gl_Position = uPMatrix * vec4(aVertexPosition.y + yAxisPos, aVertexPosition.x + xAxisPos, 0.0, 1.0);',\n            '} else if (isInverted) {',\n            // But when calculating pixel positions directly,\n            // swap axes and values (x, y)\n            'gl_Position = uPMatrix * vec4(yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, xToPixels(aVertexPosition.x) + xAxisPos, 0.0, 1.0);',\n            '} else {',\n            'gl_Position = uPMatrix * vec4(xToPixels(aVertexPosition.x) + xAxisPos, yToPixels(aVertexPosition.y, aVertexPosition.z) + yAxisPos, 0.0, 1.0);',\n            '}',\n            // 'gl_Position = uPMatrix * vec4(aVertexPosition.x, aVertexPosition.y, 0.0, 1.0);',\n            '}'\n            /* eslint-enable max-len, @typescript-eslint/indent */\n        ].join('\\n');\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * A static shader mimicing axis translation functions found in Core/Axis\n         *\n         * @private\n         *\n         * @param {WebGLContext} gl\n         * the context in which the shader is active\n         */\n        class WGLShader {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(gl) {\n                // Error stack\n                this.errors = [];\n                this.uLocations = {};\n                this.gl = gl;\n                if (gl && !this.createShader()) {\n                    return void 0;\n                }\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Bind the shader.\n             * This makes the shader the active one until another one is bound,\n             * or until 0 is bound.\n             * @private\n             */\n            bind() {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.useProgram(this.shaderProgram);\n                }\n            }\n            /**\n             * Create the shader.\n             * Loads the shader program statically defined above\n             * @private\n             */\n            createShader() {\n                const v = this.stringToProgram(vertexShader, 'vertex'), f = this.stringToProgram(fragmentShader, 'fragment'), uloc = (n) => (this.gl.getUniformLocation(this.shaderProgram, n));\n                if (!v || !f) {\n                    this.shaderProgram = false;\n                    this.handleErrors();\n                    return false;\n                }\n                this.shaderProgram = this.gl.createProgram();\n                this.gl.attachShader(this.shaderProgram, v);\n                this.gl.attachShader(this.shaderProgram, f);\n                this.gl.linkProgram(this.shaderProgram);\n                if (!this.gl.getProgramParameter(this.shaderProgram, this.gl.LINK_STATUS)) {\n                    this.errors.push(this.gl.getProgramInfoLog(this.shaderProgram));\n                    this.handleErrors();\n                    this.shaderProgram = false;\n                    return false;\n                }\n                this.gl.useProgram(this.shaderProgram);\n                this.gl.bindAttribLocation(this.shaderProgram, 0, 'aVertexPosition');\n                this.pUniform = uloc('uPMatrix');\n                this.psUniform = uloc('pSize');\n                this.fcUniform = uloc('fillColor');\n                this.isBubbleUniform = uloc('isBubble');\n                this.bubbleSizeAbsUniform = uloc('bubbleSizeAbs');\n                this.bubbleSizeAreaUniform = uloc('bubbleSizeByArea');\n                this.uSamplerUniform = uloc('uSampler');\n                this.skipTranslationUniform = uloc('skipTranslation');\n                this.isCircleUniform = uloc('isCircle');\n                this.isInverted = uloc('isInverted');\n                return true;\n            }\n            /**\n             * Handle errors accumulated in errors stack\n             * @private\n             */\n            handleErrors() {\n                if (this.errors.length) {\n                    error('[highcharts boost] shader error - ' +\n                        this.errors.join('\\n'));\n                }\n            }\n            /**\n             * String to shader program\n             * @private\n             * @param {string} str\n             * Program source\n             * @param {string} type\n             * Program type: either `vertex` or `fragment`\n             */\n            stringToProgram(str, type) {\n                const shader = this.gl.createShader(type === 'vertex' ? this.gl.VERTEX_SHADER : this.gl.FRAGMENT_SHADER);\n                this.gl.shaderSource(shader, str);\n                this.gl.compileShader(shader);\n                if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {\n                    this.errors.push('when compiling ' +\n                        type +\n                        ' shader:\\n' +\n                        this.gl.getShaderInfoLog(shader));\n                    return false;\n                }\n                return shader;\n            }\n            /**\n             * Destroy the shader\n             * @private\n             */\n            destroy() {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.deleteProgram(this.shaderProgram);\n                    this.shaderProgram = false;\n                }\n            }\n            fillColorUniform() {\n                return this.fcUniform;\n            }\n            /**\n             * Get the shader program handle\n             * @private\n             * @return {WebGLProgram}\n             * The handle for the program\n             */\n            getProgram() {\n                return this.shaderProgram;\n            }\n            pointSizeUniform() {\n                return this.psUniform;\n            }\n            perspectiveUniform() {\n                return this.pUniform;\n            }\n            /**\n             * Flush\n             * @private\n             */\n            reset() {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1i(this.isBubbleUniform, 0);\n                    this.gl.uniform1i(this.isCircleUniform, 0);\n                }\n            }\n            /**\n             * Set bubble uniforms\n             * @private\n             * @param {Highcharts.Series} series\n             * Series to use\n             */\n            setBubbleUniforms(series, zCalcMin, zCalcMax, pixelRatio = 1) {\n                const seriesOptions = series.options;\n                let zMin = Number.MAX_VALUE, zMax = -Number.MAX_VALUE;\n                if (this.gl && this.shaderProgram && series.is('bubble')) {\n                    const pxSizes = series.getPxExtremes();\n                    zMin = pick(seriesOptions.zMin, clamp(zCalcMin, seriesOptions.displayNegative === false ?\n                        seriesOptions.zThreshold : -Number.MAX_VALUE, zMin));\n                    zMax = pick(seriesOptions.zMax, Math.max(zMax, zCalcMax));\n                    this.gl.uniform1i(this.isBubbleUniform, 1);\n                    this.gl.uniform1i(this.isCircleUniform, 1);\n                    this.gl.uniform1i(this.bubbleSizeAreaUniform, (series.options.sizeBy !== 'width'));\n                    this.gl.uniform1i(this.bubbleSizeAbsUniform, series.options\n                        .sizeByAbsoluteValue);\n                    this.setUniform('bubbleMinSize', pxSizes.minPxSize * pixelRatio);\n                    this.setUniform('bubbleMaxSize', pxSizes.maxPxSize * pixelRatio);\n                    this.setUniform('bubbleZMin', zMin);\n                    this.setUniform('bubbleZMax', zMax);\n                    this.setUniform('bubbleZThreshold', series.options.zThreshold);\n                }\n            }\n            /**\n             * Set the Color uniform.\n             * @private\n             * @param {Array<number>} color\n             * Array with RGBA values.\n             */\n            setColor(color) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform4f(this.fcUniform, color[0] / 255.0, color[1] / 255.0, color[2] / 255.0, color[3]);\n                }\n            }\n            /**\n             * Enable/disable circle drawing\n             * @private\n             */\n            setDrawAsCircle(flag) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1i(this.isCircleUniform, flag ? 1 : 0);\n                }\n            }\n            /**\n             * Set if inversion state\n             * @private\n             * @param {number} flag\n             * Inversion flag\n             */\n            setInverted(flag) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1i(this.isInverted, flag);\n                }\n            }\n            /**\n             * Set the perspective matrix\n             * @private\n             * @param {Float32List} m\n             * Matrix 4 x 4\n             */\n            setPMatrix(m) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniformMatrix4fv(this.pUniform, false, m);\n                }\n            }\n            /**\n             * Set the point size.\n             * @private\n             * @param {number} p\n             * Point size\n             */\n            setPointSize(p) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1f(this.psUniform, p);\n                }\n            }\n            /**\n             * Set skip translation\n             * @private\n             */\n            setSkipTranslation(flag) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1i(this.skipTranslationUniform, flag === true ? 1 : 0);\n                }\n            }\n            /**\n             * Set the active texture\n             * @private\n             * @param {number} texture\n             * Texture to activate\n             */\n            setTexture(texture) {\n                if (this.gl && this.shaderProgram) {\n                    this.gl.uniform1i(this.uSamplerUniform, texture);\n                }\n            }\n            /**\n             * Set a uniform value.\n             * This uses a hash map to cache uniform locations.\n             * @private\n             * @param {string} name\n             * Name of the uniform to set.\n             * @param {number} val\n             * Value to set\n             */\n            setUniform(name, val) {\n                if (this.gl && this.shaderProgram) {\n                    const u = this.uLocations[name] = (this.uLocations[name] ||\n                        this.gl.getUniformLocation(this.shaderProgram, name));\n                    this.gl.uniform1f(u, val);\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WGLShader;\n    });\n    _registerModule(_modules, 'Extensions/Boost/WGLVertexBuffer.js', [], function () {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * Vertex Buffer abstraction.\n         * A vertex buffer is a set of vertices which are passed to the GPU\n         * in a single call.\n         *\n         * @private\n         * @class\n         * @name WGLVertexBuffer\n         *\n         * @param {WebGLContext} gl\n         * Context in which to create the buffer.\n         * @param {WGLShader} shader\n         * Shader to use.\n         */\n        class WGLVertexBuffer {\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(gl, shader, dataComponents\n            /* , type */\n            ) {\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.buffer = false;\n                this.iterator = 0;\n                this.preAllocated = false;\n                this.vertAttribute = false;\n                this.components = dataComponents || 2;\n                this.dataComponents = dataComponents;\n                this.gl = gl;\n                this.shader = shader;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Note about pre-allocated buffers:\n             *     - This is slower for charts with many series\n             * @private\n             */\n            allocate(size) {\n                this.iterator = -1;\n                this.preAllocated = new Float32Array(size * 4);\n            }\n            /**\n             * Bind the buffer\n             * @private\n             */\n            bind() {\n                if (!this.buffer) {\n                    return false;\n                }\n                // gl.bindAttribLocation(shader.program(), 0, 'aVertexPosition');\n                // gl.enableVertexAttribArray(vertAttribute);\n                // gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n                this.gl.vertexAttribPointer(this.vertAttribute, this.components, this.gl.FLOAT, false, 0, 0);\n                // gl.enableVertexAttribArray(vertAttribute);\n            }\n            /**\n             * Build the buffer\n             * @private\n             * @param {Array<number>} dataIn\n             * Zero padded array of indices\n             * @param {string} attrib\n             * Name of the Attribute to bind the buffer to\n             * @param {number} dataComponents\n             * Mumber of components per. indice\n             */\n            build(dataIn, attrib, dataComponents) {\n                let farray;\n                this.data = dataIn || [];\n                if ((!this.data || this.data.length === 0) && !this.preAllocated) {\n                    // console.error('trying to render empty vbuffer');\n                    this.destroy();\n                    return false;\n                }\n                this.components = dataComponents || this.components;\n                if (this.buffer) {\n                    this.gl.deleteBuffer(this.buffer);\n                }\n                if (!this.preAllocated) {\n                    farray = new Float32Array(this.data);\n                }\n                this.buffer = this.gl.createBuffer();\n                this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffer);\n                this.gl.bufferData(this.gl.ARRAY_BUFFER, this.preAllocated || farray, this.gl.STATIC_DRAW);\n                // gl.bindAttribLocation(shader.program(), 0, 'aVertexPosition');\n                this.vertAttribute = this.gl\n                    .getAttribLocation(this.shader.getProgram(), attrib);\n                this.gl.enableVertexAttribArray(this.vertAttribute);\n                // Trigger cleanup\n                farray = false;\n                return true;\n            }\n            /**\n             * @private\n             */\n            destroy() {\n                if (this.buffer) {\n                    this.gl.deleteBuffer(this.buffer);\n                    this.buffer = false;\n                    this.vertAttribute = false;\n                }\n                this.iterator = 0;\n                this.components = this.dataComponents || 2;\n                this.data = [];\n            }\n            /**\n             * Adds data to the pre-allocated buffer.\n             * @private\n             * @param {number} x\n             * X data\n             * @param {number} y\n             * Y data\n             * @param {number} a\n             * A data\n             * @param {number} b\n             * B data\n             */\n            push(x, y, a, b) {\n                if (this.preAllocated) { // && iterator <= preAllocated.length - 4) {\n                    this.preAllocated[++this.iterator] = x;\n                    this.preAllocated[++this.iterator] = y;\n                    this.preAllocated[++this.iterator] = a;\n                    this.preAllocated[++this.iterator] = b;\n                }\n            }\n            /**\n             * Render the buffer\n             *\n             * @private\n             * @param {number} from\n             * Start indice.\n             * @param {number} to\n             * End indice.\n             * @param {WGLDrawModeValue} drawMode\n             * Draw mode.\n             */\n            render(from, to, drawMode) {\n                const length = this.preAllocated ?\n                    this.preAllocated.length : this.data.length;\n                if (!this.buffer) {\n                    return false;\n                }\n                if (!length) {\n                    return false;\n                }\n                if (!from || from > length || from < 0) {\n                    from = 0;\n                }\n                if (!to || to > length) {\n                    to = length;\n                }\n                if (from >= to) {\n                    return false;\n                }\n                drawMode = drawMode || 'POINTS';\n                this.gl.drawArrays(this.gl[drawMode], from / this.components, (to - from) / this.components);\n                return true;\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WGLVertexBuffer;\n    });\n    _registerModule(_modules, 'Extensions/Boost/WGLRenderer.js', [_modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Extensions/Boost/WGLDrawMode.js'], _modules['Extensions/Boost/WGLShader.js'], _modules['Extensions/Boost/WGLVertexBuffer.js']], function (Color, H, U, WGLDrawMode, WGLShader, WGLVertexBuffer) {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { parse: color } = Color;\n        const { doc, win } = H;\n        const { isNumber, isObject, merge, objectEach, pick } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        // Things to draw as \"rectangles\" (i.e lines)\n        const asBar = {\n            'column': true,\n            'columnrange': true,\n            'bar': true,\n            'area': true,\n            'areaspline': true,\n            'arearange': true\n        };\n        const asCircle = {\n            'scatter': true,\n            'bubble': true\n        };\n        const contexts = [\n            'webgl',\n            'experimental-webgl',\n            'moz-webgl',\n            'webkit-3d'\n        ];\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /* eslint-disable valid-jsdoc */\n        /**\n         * Main renderer. Used to render series.\n         *\n         * Notes to self:\n         * - May be able to build a point map by rendering to a separate canvas and\n         *   encoding values in the color data.\n         * - Need to figure out a way to transform the data quicker\n         *\n         * @private\n         *\n         * @param {Function} postRenderCallback\n         */\n        class WGLRenderer {\n            /* *\n             *\n             *  Static Functions\n             *\n             * */\n            /**\n             * Returns an orthographic perspective matrix\n             * @private\n             * @param {number} width\n             * the width of the viewport in pixels\n             * @param {number} height\n             * the height of the viewport in pixels\n             */\n            static orthoMatrix(width, height) {\n                const near = 0, far = 1;\n                return [\n                    2 / width, 0, 0, 0,\n                    0, -(2 / height), 0, 0,\n                    0, 0, -2 / (far - near), 0,\n                    -1, 1, -(far + near) / (far - near), 1\n                ];\n            }\n            /**\n             * @private\n             */\n            static seriesPointCount(series) {\n                let isStacked, xData, s;\n                if (series.boosted) {\n                    isStacked = !!series.options.stacking;\n                    xData = (series.xData ||\n                        series.options.xData ||\n                        series.processedXData);\n                    s = (isStacked ? series.data : (xData || series.options.data))\n                        .length;\n                    if (series.type === 'treemap') {\n                        s *= 12;\n                    }\n                    else if (series.type === 'heatmap') {\n                        s *= 6;\n                    }\n                    else if (asBar[series.type]) {\n                        s *= 2;\n                    }\n                    return s;\n                }\n                return 0;\n            }\n            /* *\n             *\n             *  Constructor\n             *\n             * */\n            constructor(postRenderCallback) {\n                // The data to render - array of coordinates\n                this.data = [];\n                // Height of our viewport in pixels\n                this.height = 0;\n                // Is it inited?\n                this.isInited = false;\n                // The marker data\n                this.markerData = [];\n                // The series stack\n                this.series = [];\n                // Texture handles\n                this.textureHandles = {};\n                // Width of our viewport in pixels\n                this.width = 0;\n                this.postRenderCallback = postRenderCallback;\n                this.settings = {\n                    pointSize: 1,\n                    lineWidth: 1,\n                    fillColor: '#AA00AA',\n                    useAlpha: true,\n                    usePreallocated: false,\n                    useGPUTranslations: false,\n                    debug: {\n                        timeRendering: false,\n                        timeSeriesProcessing: false,\n                        timeSetup: false,\n                        timeBufferCopy: false,\n                        timeKDTree: false,\n                        showSkipSummary: false\n                    }\n                };\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            getPixelRatio() {\n                return this.settings.pixelRatio || win.devicePixelRatio || 1;\n            }\n            /**\n             * @private\n             */\n            setOptions(options) {\n                // The pixelRatio defaults to 1. This is an antipattern, we should\n                // refactor the Boost options to include an object of default options as\n                // base for the merge, like other components.\n                if (!('pixelRatio' in options)) {\n                    options.pixelRatio = 1;\n                }\n                merge(true, this.settings, options);\n            }\n            /**\n             * Allocate a float buffer to fit all series\n             * @private\n             */\n            allocateBuffer(chart) {\n                const vbuffer = this.vbuffer;\n                let s = 0;\n                if (!this.settings.usePreallocated) {\n                    return;\n                }\n                chart.series.forEach((series) => {\n                    if (series.boosted) {\n                        s += WGLRenderer.seriesPointCount(series);\n                    }\n                });\n                vbuffer && vbuffer.allocate(s);\n            }\n            /**\n             * @private\n             */\n            allocateBufferForSingleSeries(series) {\n                const vbuffer = this.vbuffer;\n                let s = 0;\n                if (!this.settings.usePreallocated) {\n                    return;\n                }\n                if (series.boosted) {\n                    s = WGLRenderer.seriesPointCount(series);\n                }\n                vbuffer && vbuffer.allocate(s);\n            }\n            /**\n             * Clear the depth and color buffer\n             * @private\n             */\n            clear() {\n                const gl = this.gl;\n                gl && gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n            }\n            /**\n             * Push data for a single series\n             * This calculates additional vertices and transforms the data to be\n             * aligned correctly in memory\n             * @private\n             */\n            pushSeriesData(series, inst) {\n                const data = this.data, settings = this.settings, vbuffer = this.vbuffer, isRange = (series.pointArrayMap &&\n                    series.pointArrayMap.join(',') === 'low,high'), { chart, options, sorted, xAxis, yAxis } = series, isStacked = !!options.stacking, rawData = options.data, xExtremes = series.xAxis.getExtremes(), xMin = xExtremes.min, xMax = xExtremes.max, yExtremes = series.yAxis.getExtremes(), yMin = yExtremes.min, yMax = yExtremes.max, xData = series.xData || options.xData || series.processedXData, yData = series.yData || options.yData || series.processedYData, zData = (series.zData || options.zData ||\n                    series.processedZData), useRaw = !xData || xData.length === 0, \n                // threshold = options.threshold,\n                // yBottom = chart.yAxis[0].getThreshold(threshold),\n                // hasThreshold = isNumber(threshold),\n                // colorByPoint = series.options.colorByPoint,\n                // This is required for color by point, so make sure this is\n                // uncommented if enabling that\n                // colorIndex = 0,\n                // Required for color axis support\n                // caxis,\n                connectNulls = options.connectNulls, \n                // For some reason eslint/TypeScript don't pick up that this is\n                // actually used: --- bre1470: it is never read, just set\n                // maxVal: (number|undefined), // eslint-disable-line no-unused-vars\n                points = series.points || false, sdata = isStacked ? series.data : (xData || rawData), closestLeft = { x: Number.MAX_VALUE, y: 0 }, closestRight = { x: -Number.MAX_VALUE, y: 0 }, cullXThreshold = 1, cullYThreshold = 1, chartDestroyed = typeof chart.index === 'undefined', drawAsBar = asBar[series.type], zoneAxis = options.zoneAxis || 'y', zones = options.zones || false, threshold = options.threshold, pixelRatio = this.getPixelRatio();\n                let // plotHeight = series.chart.plotHeight,\n                plotWidth = series.chart.plotWidth, lastX = false, lastY = false, minVal, scolor, \n                //\n                skipped = 0, hadPoints = false, \n                // The following are used in the builder while loop\n                x, y, d, z, i = -1, px = false, nx = false, low, nextInside = false, prevInside = false, pcolor = false, isXInside = false, isYInside = true, firstPoint = true, zoneColors, zoneDefColor = false, gapSize = false, vlen = 0;\n                if (options.boostData && options.boostData.length > 0) {\n                    return;\n                }\n                if (options.gapSize) {\n                    gapSize = options.gapUnit !== 'value' ?\n                        options.gapSize * series.closestPointRange :\n                        options.gapSize;\n                }\n                if (zones) {\n                    zoneColors = [];\n                    zones.forEach((zone, i) => {\n                        if (zone.color) {\n                            const zoneColor = color(zone.color).rgba;\n                            zoneColor[0] /= 255.0;\n                            zoneColor[1] /= 255.0;\n                            zoneColor[2] /= 255.0;\n                            zoneColors[i] = zoneColor;\n                            if (!zoneDefColor && typeof zone.value === 'undefined') {\n                                zoneDefColor = zoneColor;\n                            }\n                        }\n                    });\n                    if (!zoneDefColor) {\n                        const seriesColor = ((series.pointAttribs && series.pointAttribs().fill) ||\n                            series.color);\n                        zoneDefColor = color(seriesColor).rgba;\n                        zoneDefColor[0] /= 255.0;\n                        zoneDefColor[1] /= 255.0;\n                        zoneDefColor[2] /= 255.0;\n                    }\n                }\n                if (chart.inverted) {\n                    // plotHeight = series.chart.plotWidth;\n                    plotWidth = series.chart.plotHeight;\n                }\n                series.closestPointRangePx = Number.MAX_VALUE;\n                /**\n                 * Push color to color buffer - need to do this per vertex.\n                 * @private\n                 */\n                const pushColor = (color) => {\n                    if (color) {\n                        inst.colorData.push(color[0]);\n                        inst.colorData.push(color[1]);\n                        inst.colorData.push(color[2]);\n                        inst.colorData.push(color[3]);\n                    }\n                };\n                /**\n                 * Push a vertice to the data buffer.\n                 * @private\n                 */\n                const vertice = (x, y, checkTreshold, pointSize = 1, color) => {\n                    pushColor(color);\n                    // Correct for pixel ratio\n                    if (pixelRatio !== 1 && (!settings.useGPUTranslations ||\n                        inst.skipTranslation)) {\n                        x *= pixelRatio;\n                        y *= pixelRatio;\n                        pointSize *= pixelRatio;\n                    }\n                    if (settings.usePreallocated && vbuffer) {\n                        vbuffer.push(x, y, checkTreshold ? 1 : 0, pointSize);\n                        vlen += 4;\n                    }\n                    else {\n                        data.push(x);\n                        data.push(y);\n                        data.push(checkTreshold ? pixelRatio : 0);\n                        data.push(pointSize);\n                    }\n                };\n                /**\n                 * @private\n                 */\n                const closeSegment = () => {\n                    if (inst.segments.length) {\n                        inst.segments[inst.segments.length - 1].to = data.length || vlen;\n                    }\n                };\n                /**\n                 * Create a new segment for the current set.\n                 * @private\n                 */\n                const beginSegment = () => {\n                    // Insert a segment on the series.\n                    // A segment is just a start indice.\n                    // When adding a segment, if one exists from before, it should\n                    // set the previous segment's end\n                    if (inst.segments.length &&\n                        inst.segments[inst.segments.length - 1].from === (data.length || vlen)) {\n                        return;\n                    }\n                    closeSegment();\n                    inst.segments.push({\n                        from: data.length || vlen\n                    });\n                };\n                /**\n                 * Push a rectangle to the data buffer.\n                 * @private\n                 */\n                const pushRect = (x, y, w, h, color) => {\n                    pushColor(color);\n                    vertice(x + w, y);\n                    pushColor(color);\n                    vertice(x, y);\n                    pushColor(color);\n                    vertice(x, y + h);\n                    pushColor(color);\n                    vertice(x, y + h);\n                    pushColor(color);\n                    vertice(x + w, y + h);\n                    pushColor(color);\n                    vertice(x + w, y);\n                };\n                // Create the first segment\n                beginSegment();\n                // Special case for point shapes\n                if (points && points.length > 0) {\n                    // If we're doing points, we assume that the points are already\n                    // translated, so we skip the shader translation.\n                    inst.skipTranslation = true;\n                    // Force triangle draw mode\n                    inst.drawMode = 'TRIANGLES';\n                    // We don't have a z component in the shader, so we need to sort.\n                    if (points[0].node && points[0].node.levelDynamic) {\n                        points.sort((a, b) => {\n                            if (a.node) {\n                                if (a.node.levelDynamic >\n                                    b.node.levelDynamic) {\n                                    return 1;\n                                }\n                                if (a.node.levelDynamic <\n                                    b.node.levelDynamic) {\n                                    return -1;\n                                }\n                            }\n                            return 0;\n                        });\n                    }\n                    points.forEach((point) => {\n                        const plotY = point.plotY;\n                        let swidth, pointAttr;\n                        if (typeof plotY !== 'undefined' &&\n                            !isNaN(plotY) &&\n                            point.y !== null &&\n                            point.shapeArgs) {\n                            let { x = 0, y = 0, width = 0, height = 0 } = point.shapeArgs;\n                            pointAttr = chart.styledMode ?\n                                point.series\n                                    .colorAttribs(point) :\n                                pointAttr = point.series.pointAttribs(point);\n                            swidth = pointAttr['stroke-width'] || 0;\n                            // Handle point colors\n                            pcolor = color(pointAttr.fill).rgba;\n                            pcolor[0] /= 255.0;\n                            pcolor[1] /= 255.0;\n                            pcolor[2] /= 255.0;\n                            // So there are two ways of doing this. Either we can\n                            // create a rectangle of two triangles, or we can do a\n                            // point and use point size. Latter is faster, but\n                            // only supports squares. So we're doing triangles.\n                            // We could also use one color per. vertice to get\n                            // better color interpolation.\n                            // If there's stroking, we do an additional rect\n                            if (series.is('treemap')) {\n                                swidth = swidth || 1;\n                                scolor = color(pointAttr.stroke).rgba;\n                                scolor[0] /= 255.0;\n                                scolor[1] /= 255.0;\n                                scolor[2] /= 255.0;\n                                pushRect(x, y, width, height, scolor);\n                                swidth /= 2;\n                            }\n                            // } else {\n                            //     swidth = 0;\n                            // }\n                            // Fixes issues with inverted heatmaps (see #6981). The root\n                            // cause is that the coordinate system is flipped. In other\n                            // words, instead of [0,0] being top-left, it's\n                            // bottom-right. This causes a vertical and horizontal flip\n                            // in the resulting image, making it rotated 180 degrees.\n                            if (series.is('heatmap') && chart.inverted) {\n                                x = xAxis.len - x;\n                                y = yAxis.len - y;\n                                width = -width;\n                                height = -height;\n                            }\n                            pushRect(x + swidth, y + swidth, width - (swidth * 2), height - (swidth * 2), pcolor);\n                        }\n                    });\n                    closeSegment();\n                    return;\n                }\n                // Extract color axis\n                // (chart.axes || []).forEach((a): void => {\n                //     if (H.ColorAxis && a instanceof H.ColorAxis) {\n                //         caxis = a;\n                //     }\n                // });\n                while (i < sdata.length - 1) {\n                    d = sdata[++i];\n                    if (typeof d === 'undefined') {\n                        continue;\n                    }\n                    // px = x = y = z = nx = low = false;\n                    // chartDestroyed = typeof chart.index === 'undefined';\n                    // nextInside = prevInside = pcolor = isXInside = isYInside = false;\n                    // drawAsBar = asBar[series.type];\n                    if (chartDestroyed) {\n                        break;\n                    }\n                    // Uncomment this to enable color by point.\n                    // This currently left disabled as the charts look really ugly\n                    // when enabled and there's a lot of points.\n                    // Leaving in for the future (tm).\n                    // if (colorByPoint) {\n                    //     colorIndex = ++colorIndex %\n                    //         series.chart.options.colors.length;\n                    //     pcolor = toRGBAFast(series.chart.options.colors[colorIndex]);\n                    //     pcolor[0] /= 255.0;\n                    //     pcolor[1] /= 255.0;\n                    //     pcolor[2] /= 255.0;\n                    // }\n                    // Handle the point.color option (#5999)\n                    const pointOptions = rawData && rawData[i];\n                    if (!useRaw && isObject(pointOptions, true)) {\n                        if (pointOptions.color) {\n                            pcolor = color(pointOptions.color).rgba;\n                            pcolor[0] /= 255.0;\n                            pcolor[1] /= 255.0;\n                            pcolor[2] /= 255.0;\n                        }\n                    }\n                    if (useRaw) {\n                        x = d[0];\n                        y = d[1];\n                        if (sdata[i + 1]) {\n                            nx = sdata[i + 1][0];\n                        }\n                        if (sdata[i - 1]) {\n                            px = sdata[i - 1][0];\n                        }\n                        if (d.length >= 3) {\n                            z = d[2];\n                            if (d[2] > inst.zMax) {\n                                inst.zMax = d[2];\n                            }\n                            if (d[2] < inst.zMin) {\n                                inst.zMin = d[2];\n                            }\n                        }\n                    }\n                    else {\n                        x = d;\n                        y = yData[i];\n                        if (sdata[i + 1]) {\n                            nx = sdata[i + 1];\n                        }\n                        if (sdata[i - 1]) {\n                            px = sdata[i - 1];\n                        }\n                        if (zData && zData.length) {\n                            z = zData[i];\n                            if (zData[i] > inst.zMax) {\n                                inst.zMax = zData[i];\n                            }\n                            if (zData[i] < inst.zMin) {\n                                inst.zMin = zData[i];\n                            }\n                        }\n                    }\n                    if (!connectNulls && (x === null || y === null)) {\n                        beginSegment();\n                        continue;\n                    }\n                    if (nx && nx >= xMin && nx <= xMax) {\n                        nextInside = true;\n                    }\n                    if (px && px >= xMin && px <= xMax) {\n                        prevInside = true;\n                    }\n                    if (isRange) {\n                        if (useRaw) {\n                            y = d.slice(1, 3);\n                        }\n                        low = y[0];\n                        y = y[1];\n                    }\n                    else if (isStacked) {\n                        x = d.x;\n                        y = d.stackY;\n                        low = y - d.y;\n                    }\n                    if (yMin !== null &&\n                        typeof yMin !== 'undefined' &&\n                        yMax !== null &&\n                        typeof yMax !== 'undefined') {\n                        isYInside = y >= yMin && y <= yMax;\n                    }\n                    if (x > xMax && closestRight.x < xMax) {\n                        closestRight.x = x;\n                        closestRight.y = y;\n                    }\n                    if (x < xMin && closestLeft.x > xMin) {\n                        closestLeft.x = x;\n                        closestLeft.y = y;\n                    }\n                    if (y === null && connectNulls) {\n                        continue;\n                    }\n                    // Cull points outside the extremes\n                    if (y === null || (!isYInside && !nextInside && !prevInside)) {\n                        beginSegment();\n                        continue;\n                    }\n                    // The first point before and first after extremes should be\n                    // rendered (#9962, 19701)\n                    if (sorted &&\n                        (nx >= xMin || x >= xMin) &&\n                        (px <= xMax || x <= xMax)) {\n                        isXInside = true;\n                    }\n                    if (!isXInside && !nextInside && !prevInside) {\n                        continue;\n                    }\n                    if (gapSize && x - px > gapSize) {\n                        beginSegment();\n                    }\n                    // Note: Boost requires that zones are sorted!\n                    if (zones) {\n                        let zoneColor;\n                        zones.some((// eslint-disable-line no-loop-func\n                        zone, i) => {\n                            const last = zones[i - 1];\n                            if (zoneAxis === 'x') {\n                                if (typeof zone.value !== 'undefined' &&\n                                    x <= zone.value) {\n                                    if (zoneColors[i] &&\n                                        (!last || x >= last.value)) {\n                                        zoneColor = zoneColors[i];\n                                    }\n                                    return true;\n                                }\n                                return false;\n                            }\n                            if (typeof zone.value !== 'undefined' && y <= zone.value) {\n                                if (zoneColors[i] &&\n                                    (!last || y >= last.value)) {\n                                    zoneColor = zoneColors[i];\n                                }\n                                return true;\n                            }\n                            return false;\n                        });\n                        pcolor = zoneColor || zoneDefColor || pcolor;\n                    }\n                    // Skip translations - temporary floating point fix\n                    if (!settings.useGPUTranslations) {\n                        inst.skipTranslation = true;\n                        x = xAxis.toPixels(x, true);\n                        y = yAxis.toPixels(y, true);\n                        // Make sure we're not drawing outside of the chart area.\n                        // See #6594. Update: this is no longer required as far as I\n                        // can tell. Leaving in for git blame in case there are edge\n                        // cases I've not found. Having this in breaks #10246.\n                        // if (y > plotHeight) {\n                        // y = plotHeight;\n                        // }\n                        if (x > plotWidth) {\n                            // If this is  rendered as a point, just skip drawing it\n                            // entirely, as we're not dependandt on lineTo'ing to it.\n                            // See #8197\n                            if (inst.drawMode === 'POINTS') {\n                                continue;\n                            }\n                            // Having this here will clamp markers and make the angle\n                            // of the last line wrong. See 9166.\n                            // x = plotWidth;\n                        }\n                    }\n                    // No markers on out of bounds things.\n                    // Out of bound things are shown if and only if the next\n                    // or previous point is inside the rect.\n                    if (inst.hasMarkers && isXInside) {\n                        // x = Highcharts.correctFloat(\n                        //     Math.min(Math.max(-1e5, xAxis.translate(\n                        //         x,\n                        //         0,\n                        //         0,\n                        //         0,\n                        //         1,\n                        //         0.5,\n                        //         false\n                        //     )), 1e5)\n                        // );\n                        if (lastX !== false) {\n                            series.closestPointRangePx = Math.min(series.closestPointRangePx, Math.abs(x - lastX));\n                        }\n                    }\n                    // If the last _drawn_ point is closer to this point than the\n                    // threshold, skip it. Shaves off 20-100ms in processing.\n                    if (!settings.useGPUTranslations &&\n                        !settings.usePreallocated &&\n                        (lastX && Math.abs(x - lastX) < cullXThreshold) &&\n                        (lastY && Math.abs(y - lastY) < cullYThreshold)) {\n                        if (settings.debug.showSkipSummary) {\n                            ++skipped;\n                        }\n                        continue;\n                    }\n                    if (drawAsBar) {\n                        // maxVal = y;\n                        minVal = low;\n                        if (low === false || typeof low === 'undefined') {\n                            if (y < 0) {\n                                minVal = y;\n                            }\n                            else {\n                                minVal = 0;\n                            }\n                        }\n                        if (!isRange && !isStacked) {\n                            minVal = Math.max(threshold === null ? yMin : threshold, // #5268\n                            yMin); // #8731\n                        }\n                        if (!settings.useGPUTranslations) {\n                            minVal = yAxis.toPixels(minVal, true);\n                        }\n                        // Need to add an extra point here\n                        vertice(x, minVal, 0, 0, pcolor);\n                    }\n                    // Do step line if enabled.\n                    // Draws an additional point at the old Y at the new X.\n                    // See #6976.\n                    if (options.step && !firstPoint) {\n                        vertice(x, lastY, 0, 2, pcolor);\n                    }\n                    vertice(x, y, 0, series.type === 'bubble' ? (z || 1) : 2, pcolor);\n                    // Uncomment this to support color axis.\n                    // if (caxis) {\n                    //     pcolor = color(caxis.toColor(y)).rgba;\n                    //     inst.colorData.push(color[0] / 255.0);\n                    //     inst.colorData.push(color[1] / 255.0);\n                    //     inst.colorData.push(color[2] / 255.0);\n                    //     inst.colorData.push(color[3]);\n                    // }\n                    lastX = x;\n                    lastY = y;\n                    hadPoints = true;\n                    firstPoint = false;\n                }\n                if (settings.debug.showSkipSummary) {\n                    console.log('skipped points:', skipped); // eslint-disable-line no-console\n                }\n                const pushSupplementPoint = (point, atStart) => {\n                    if (!settings.useGPUTranslations) {\n                        inst.skipTranslation = true;\n                        point.x = xAxis.toPixels(point.x, true);\n                        point.y = yAxis.toPixels(point.y, true);\n                    }\n                    // We should only do this for lines, and we should ignore markers\n                    // since there's no point here that would have a marker.\n                    if (atStart) {\n                        this.data = [point.x, point.y, 0, 2].concat(this.data);\n                        return;\n                    }\n                    vertice(point.x, point.y, 0, 2);\n                };\n                if (!hadPoints &&\n                    connectNulls !== false &&\n                    series.drawMode === 'line_strip') {\n                    if (closestLeft.x < Number.MAX_VALUE) {\n                        // We actually need to push this *before* the complete buffer.\n                        pushSupplementPoint(closestLeft, true);\n                    }\n                    if (closestRight.x > -Number.MAX_VALUE) {\n                        pushSupplementPoint(closestRight);\n                    }\n                }\n                closeSegment();\n            }\n            /**\n             * Push a series to the renderer\n             * If we render the series immediatly, we don't have to loop later\n             * @private\n             * @param {Highchart.Series} s\n             * The series to push.\n             */\n            pushSeries(s) {\n                const markerData = this.markerData, series = this.series, settings = this.settings;\n                if (series.length > 0) {\n                    // series[series.length - 1].to = data.length;\n                    if (series[series.length - 1].hasMarkers) {\n                        series[series.length - 1].markerTo = markerData.length;\n                    }\n                }\n                if (settings.debug.timeSeriesProcessing) {\n                    console.time('building ' + s.type + ' series'); // eslint-disable-line no-console\n                }\n                const obj = {\n                    segments: [],\n                    // from: data.length,\n                    markerFrom: markerData.length,\n                    // Push RGBA values to this array to use per. point coloring.\n                    // It should be 0-padded, so each component should be pushed in\n                    // succession.\n                    colorData: [],\n                    series: s,\n                    zMin: Number.MAX_VALUE,\n                    zMax: -Number.MAX_VALUE,\n                    hasMarkers: s.options.marker ?\n                        s.options.marker.enabled !== false :\n                        false,\n                    showMarkers: true,\n                    drawMode: WGLDrawMode[s.type] || 'LINE_STRIP'\n                };\n                if (s.index >= series.length) {\n                    series.push(obj);\n                }\n                else {\n                    series[s.index] = obj;\n                }\n                // Add the series data to our buffer(s)\n                this.pushSeriesData(s, obj);\n                if (settings.debug.timeSeriesProcessing) {\n                    console.timeEnd('building ' + s.type + ' series'); // eslint-disable-line no-console\n                }\n            }\n            /**\n             * Flush the renderer.\n             * This removes pushed series and vertices.\n             * Should be called after clearing and before rendering\n             * @private\n             */\n            flush() {\n                const vbuffer = this.vbuffer;\n                this.data = [];\n                this.markerData = [];\n                this.series = [];\n                if (vbuffer) {\n                    vbuffer.destroy();\n                }\n            }\n            /**\n             * Pass x-axis to shader\n             * @private\n             * @param {Highcharts.Axis} axis\n             * The x-axis.\n             */\n            setXAxis(axis) {\n                const shader = this.shader;\n                if (!shader) {\n                    return;\n                }\n                const pixelRatio = this.getPixelRatio();\n                shader.setUniform('xAxisTrans', axis.transA * pixelRatio);\n                shader.setUniform('xAxisMin', axis.min);\n                shader.setUniform('xAxisMinPad', axis.minPixelPadding * pixelRatio);\n                shader.setUniform('xAxisPointRange', axis.pointRange);\n                shader.setUniform('xAxisLen', axis.len * pixelRatio);\n                shader.setUniform('xAxisPos', axis.pos * pixelRatio);\n                shader.setUniform('xAxisCVSCoord', (!axis.horiz));\n                shader.setUniform('xAxisIsLog', (!!axis.logarithmic));\n                shader.setUniform('xAxisReversed', (!!axis.reversed));\n            }\n            /**\n             * Pass y-axis to shader\n             * @private\n             * @param {Highcharts.Axis} axis\n             * The y-axis.\n             */\n            setYAxis(axis) {\n                const shader = this.shader;\n                if (!shader) {\n                    return;\n                }\n                const pixelRatio = this.getPixelRatio();\n                shader.setUniform('yAxisTrans', axis.transA * pixelRatio);\n                shader.setUniform('yAxisMin', axis.min);\n                shader.setUniform('yAxisMinPad', axis.minPixelPadding * pixelRatio);\n                shader.setUniform('yAxisPointRange', axis.pointRange);\n                shader.setUniform('yAxisLen', axis.len * pixelRatio);\n                shader.setUniform('yAxisPos', axis.pos * pixelRatio);\n                shader.setUniform('yAxisCVSCoord', (!axis.horiz));\n                shader.setUniform('yAxisIsLog', (!!axis.logarithmic));\n                shader.setUniform('yAxisReversed', (!!axis.reversed));\n            }\n            /**\n             * Set the translation threshold\n             * @private\n             * @param {boolean} has\n             * Has threshold flag.\n             * @param {numbe} translation\n             * The threshold.\n             */\n            setThreshold(has, translation) {\n                const shader = this.shader;\n                if (!shader) {\n                    return;\n                }\n                shader.setUniform('hasThreshold', has);\n                shader.setUniform('translatedThreshold', translation);\n            }\n            /**\n             * Render the data\n             * This renders all pushed series.\n             * @private\n             */\n            renderChart(chart) {\n                const gl = this.gl, settings = this.settings, shader = this.shader, vbuffer = this.vbuffer;\n                const pixelRatio = this.getPixelRatio();\n                if (chart) {\n                    this.width = chart.chartWidth * pixelRatio;\n                    this.height = chart.chartHeight * pixelRatio;\n                }\n                else {\n                    return false;\n                }\n                const height = this.height, width = this.width;\n                if (!gl || !shader || !width || !height) {\n                    return false;\n                }\n                if (settings.debug.timeRendering) {\n                    console.time('gl rendering'); // eslint-disable-line no-console\n                }\n                gl.canvas.width = width;\n                gl.canvas.height = height;\n                shader.bind();\n                gl.viewport(0, 0, width, height);\n                shader.setPMatrix(WGLRenderer.orthoMatrix(width, height));\n                if (settings.lineWidth > 1 && !H.isMS) {\n                    gl.lineWidth(settings.lineWidth);\n                }\n                if (vbuffer) {\n                    vbuffer.build(this.data, 'aVertexPosition', 4);\n                    vbuffer.bind();\n                }\n                shader.setInverted(chart.inverted);\n                // Render the series\n                this.series.forEach((s, si) => {\n                    const options = s.series.options, shapeOptions = options.marker, lineWidth = (typeof options.lineWidth !== 'undefined' ?\n                        options.lineWidth :\n                        1), threshold = options.threshold, hasThreshold = isNumber(threshold), yBottom = s.series.yAxis.getThreshold(threshold), translatedThreshold = yBottom, showMarkers = pick(options.marker ? options.marker.enabled : null, s.series.xAxis.isRadial ? true : null, s.series.closestPointRangePx >\n                        2 * ((options.marker ?\n                            options.marker.radius :\n                            10) || 10)), shapeTexture = this.textureHandles[(shapeOptions && shapeOptions.symbol) ||\n                        s.series.symbol] || this.textureHandles.circle;\n                    let sindex, cbuffer, fillColor, scolor = [];\n                    if (s.segments.length === 0 ||\n                        s.segments[0].from === s.segments[0].to) {\n                        return;\n                    }\n                    if (shapeTexture.isReady) {\n                        gl.bindTexture(gl.TEXTURE_2D, shapeTexture.handle);\n                        shader.setTexture(shapeTexture.handle);\n                    }\n                    if (chart.styledMode) {\n                        fillColor = (s.series.markerGroup &&\n                            s.series.markerGroup.getStyle('fill'));\n                    }\n                    else {\n                        fillColor =\n                            (s.drawMode === 'POINTS' && // #14260\n                                s.series.pointAttribs &&\n                                s.series.pointAttribs().fill) ||\n                                s.series.color;\n                        if (options.colorByPoint) {\n                            fillColor = s.series.chart.options.colors[si];\n                        }\n                    }\n                    if (s.series.fillOpacity && options.fillOpacity) {\n                        fillColor = new Color(fillColor).setOpacity(pick(options.fillOpacity, 1.0)).get();\n                    }\n                    scolor = color(fillColor).rgba;\n                    if (!settings.useAlpha) {\n                        scolor[3] = 1.0;\n                    }\n                    // This is very much temporary\n                    if (s.drawMode === 'LINES' &&\n                        settings.useAlpha &&\n                        scolor[3] < 1) {\n                        scolor[3] /= 10;\n                    }\n                    // Blending\n                    if (options.boostBlending === 'add') {\n                        gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n                        gl.blendEquation(gl.FUNC_ADD);\n                    }\n                    else if (options.boostBlending === 'mult' ||\n                        options.boostBlending === 'multiply') {\n                        gl.blendFunc(gl.DST_COLOR, gl.ZERO);\n                    }\n                    else if (options.boostBlending === 'darken') {\n                        gl.blendFunc(gl.ONE, gl.ONE);\n                        gl.blendEquation(gl.FUNC_MIN);\n                    }\n                    else {\n                        // gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n                        // gl.blendEquation(gl.FUNC_ADD);\n                        gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n                    }\n                    shader.reset();\n                    // If there are entries in the colorData buffer, build and bind it.\n                    if (s.colorData.length > 0) {\n                        shader.setUniform('hasColor', 1);\n                        cbuffer = new WGLVertexBuffer(gl, shader);\n                        cbuffer.build(\n                        // The color array attribute for vertex is assigned from 0,\n                        // so it needs to be shifted to be applied to further\n                        // segments. #18858\n                        Array(s.segments[0].from).concat(s.colorData), 'aColor', 4);\n                        cbuffer.bind();\n                    }\n                    else {\n                        // Set the hasColor uniform to false (0) when the series\n                        // contains no colorData buffer points. #18858\n                        shader.setUniform('hasColor', 0);\n                        // #15869, a buffer with fewer points might already be bound by\n                        // a different series/chart causing out of range errors\n                        gl.disableVertexAttribArray(gl.getAttribLocation(shader.getProgram(), 'aColor'));\n                    }\n                    // Set series specific uniforms\n                    shader.setColor(scolor);\n                    this.setXAxis(s.series.xAxis);\n                    this.setYAxis(s.series.yAxis);\n                    this.setThreshold(hasThreshold, translatedThreshold);\n                    if (s.drawMode === 'POINTS') {\n                        shader.setPointSize(pick(options.marker && options.marker.radius, 0.5) * 2 * pixelRatio);\n                    }\n                    // If set to true, the toPixels translations in the shader\n                    // is skipped, i.e it's assumed that the value is a pixel coord.\n                    shader.setSkipTranslation(s.skipTranslation);\n                    if (s.series.type === 'bubble') {\n                        shader.setBubbleUniforms(s.series, s.zMin, s.zMax, pixelRatio);\n                    }\n                    shader.setDrawAsCircle(asCircle[s.series.type] || false);\n                    if (!vbuffer) {\n                        return;\n                    }\n                    // Do the actual rendering\n                    // If the line width is < 0, skip rendering of the lines. See #7833.\n                    if (lineWidth > 0 || s.drawMode !== 'LINE_STRIP') {\n                        for (sindex = 0; sindex < s.segments.length; sindex++) {\n                            vbuffer.render(s.segments[sindex].from, s.segments[sindex].to, s.drawMode);\n                        }\n                    }\n                    if (s.hasMarkers && showMarkers) {\n                        shader.setPointSize(pick(options.marker && options.marker.radius, 5) * 2 * pixelRatio);\n                        shader.setDrawAsCircle(true);\n                        for (sindex = 0; sindex < s.segments.length; sindex++) {\n                            vbuffer.render(s.segments[sindex].from, s.segments[sindex].to, 'POINTS');\n                        }\n                    }\n                });\n                if (settings.debug.timeRendering) {\n                    console.timeEnd('gl rendering'); // eslint-disable-line no-console\n                }\n                if (this.postRenderCallback) {\n                    this.postRenderCallback(this);\n                }\n                this.flush();\n            }\n            /**\n             * Render the data when ready\n             * @private\n             */\n            render(chart) {\n                this.clear();\n                if (chart.renderer.forExport) {\n                    return this.renderChart(chart);\n                }\n                if (this.isInited) {\n                    this.renderChart(chart);\n                }\n                else {\n                    setTimeout(() => {\n                        this.render(chart);\n                    }, 1);\n                }\n            }\n            /**\n             * Set the viewport size in pixels\n             * Creates an orthographic perspective matrix and applies it.\n             * @private\n             */\n            setSize(width, height) {\n                const shader = this.shader;\n                // Skip if there's no change, or if we have no valid shader\n                if (!shader || (this.width === width && this.height === height)) {\n                    return;\n                }\n                this.width = width;\n                this.height = height;\n                shader.bind();\n                shader.setPMatrix(WGLRenderer.orthoMatrix(width, height));\n            }\n            /**\n             * Init OpenGL\n             * @private\n             */\n            init(canvas, noFlush) {\n                const settings = this.settings;\n                this.isInited = false;\n                if (!canvas) {\n                    return false;\n                }\n                if (settings.debug.timeSetup) {\n                    console.time('gl setup'); // eslint-disable-line no-console\n                }\n                for (let i = 0; i < contexts.length; ++i) {\n                    this.gl = canvas.getContext(contexts[i], {\n                    //    premultipliedAlpha: false\n                    });\n                    if (this.gl) {\n                        break;\n                    }\n                }\n                const gl = this.gl;\n                if (gl) {\n                    if (!noFlush) {\n                        this.flush();\n                    }\n                }\n                else {\n                    return false;\n                }\n                gl.enable(gl.BLEND);\n                // gl.blendFunc(gl.SRC_ALPHA, gl.ONE);\n                gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n                gl.disable(gl.DEPTH_TEST);\n                // gl.depthMask(gl.FALSE);\n                gl.depthFunc(gl.LESS);\n                const shader = this.shader = new WGLShader(gl);\n                if (!shader) {\n                    // We need to abort, there's no shader context\n                    return false;\n                }\n                this.vbuffer = new WGLVertexBuffer(gl, shader);\n                const createTexture = (name, fn) => {\n                    const props = {\n                        isReady: false,\n                        texture: doc.createElement('canvas'),\n                        handle: gl.createTexture()\n                    }, ctx = props.texture.getContext('2d');\n                    this.textureHandles[name] = props;\n                    props.texture.width = 512;\n                    props.texture.height = 512;\n                    ctx.mozImageSmoothingEnabled = false;\n                    ctx.webkitImageSmoothingEnabled = false;\n                    ctx.msImageSmoothingEnabled = false;\n                    ctx.imageSmoothingEnabled = false;\n                    ctx.strokeStyle = 'rgba(255, 255, 255, 0)';\n                    ctx.fillStyle = '#FFF';\n                    fn(ctx);\n                    try {\n                        gl.activeTexture(gl.TEXTURE0);\n                        gl.bindTexture(gl.TEXTURE_2D, props.handle);\n                        // gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);\n                        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, props.texture);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n                        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n                        // gl.generateMipmap(gl.TEXTURE_2D);\n                        gl.bindTexture(gl.TEXTURE_2D, null);\n                        props.isReady = true;\n                    }\n                    catch (e) {\n                        // silent error\n                    }\n                };\n                // Circle shape\n                createTexture('circle', (ctx) => {\n                    ctx.beginPath();\n                    ctx.arc(256, 256, 256, 0, 2 * Math.PI);\n                    ctx.stroke();\n                    ctx.fill();\n                });\n                // Square shape\n                createTexture('square', (ctx) => {\n                    ctx.fillRect(0, 0, 512, 512);\n                });\n                // Diamond shape\n                createTexture('diamond', (ctx) => {\n                    ctx.beginPath();\n                    ctx.moveTo(256, 0);\n                    ctx.lineTo(512, 256);\n                    ctx.lineTo(256, 512);\n                    ctx.lineTo(0, 256);\n                    ctx.lineTo(256, 0);\n                    ctx.fill();\n                });\n                // Triangle shape\n                createTexture('triangle', (ctx) => {\n                    ctx.beginPath();\n                    ctx.moveTo(0, 512);\n                    ctx.lineTo(256, 0);\n                    ctx.lineTo(512, 512);\n                    ctx.lineTo(0, 512);\n                    ctx.fill();\n                });\n                // Triangle shape (rotated)\n                createTexture('triangle-down', (ctx) => {\n                    ctx.beginPath();\n                    ctx.moveTo(0, 0);\n                    ctx.lineTo(256, 512);\n                    ctx.lineTo(512, 0);\n                    ctx.lineTo(0, 0);\n                    ctx.fill();\n                });\n                this.isInited = true;\n                if (settings.debug.timeSetup) {\n                    console.timeEnd('gl setup'); // eslint-disable-line no-console\n                }\n                return true;\n            }\n            /**\n             * @private\n             * @todo use it\n             */\n            destroy() {\n                const gl = this.gl, shader = this.shader, vbuffer = this.vbuffer;\n                this.flush();\n                if (vbuffer) {\n                    vbuffer.destroy();\n                }\n                if (shader) {\n                    shader.destroy();\n                }\n                if (gl) {\n                    objectEach(this.textureHandles, (texture) => {\n                        if (texture.handle) {\n                            gl.deleteTexture(texture.handle);\n                        }\n                    });\n                    gl.canvas.width = 1;\n                    gl.canvas.height = 1;\n                }\n            }\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return WGLRenderer;\n    });\n    _registerModule(_modules, 'Extensions/Boost/BoostSeries.js', [_modules['Extensions/Boost/BoostableMap.js'], _modules['Extensions/Boost/Boostables.js'], _modules['Extensions/Boost/BoostChart.js'], _modules['Core/Defaults.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js'], _modules['Extensions/Boost/WGLRenderer.js']], function (BoostableMap, Boostables, BoostChart, D, H, U, WGLRenderer) {\n        /* *\n         *\n         *  Copyright (c) 2019-2021 Highsoft AS\n         *\n         *  Boost module: stripped-down renderer for higher performance\n         *\n         *  License: highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getBoostClipRect, isChartSeriesBoosting } = BoostChart;\n        const { getOptions } = D;\n        const { doc, noop, win } = H;\n        const { addEvent, error, extend, fireEvent, isArray, isNumber, pick, wrap, defined } = U;\n        /* *\n         *\n         *  Constants\n         *\n         * */\n        const CHUNK_SIZE = 3000;\n        const composedMembers = [];\n        /* *\n         *\n         *  Variables\n         *\n         * */\n        let index, mainCanvas;\n        /* *\n         *\n         *  Functions\n         *\n         * */\n        /**\n         * @private\n         */\n        function allocateIfNotSeriesBoosting(renderer, series) {\n            const boost = series.boost;\n            if (renderer &&\n                boost &&\n                boost.target &&\n                boost.canvas &&\n                !isChartSeriesBoosting(series.chart)) {\n                renderer.allocateBufferForSingleSeries(series);\n            }\n        }\n        /**\n         * Return true if ths boost.enabled option is true\n         *\n         * @private\n         * @param {Highcharts.Chart} chart\n         * The chart\n         * @return {boolean}\n         * True, if boost is enabled.\n         */\n        function boostEnabled(chart) {\n            return pick((chart &&\n                chart.options &&\n                chart.options.boost &&\n                chart.options.boost.enabled), true);\n        }\n        /**\n         * @private\n         */\n        function compose(SeriesClass, seriesTypes, wglMode) {\n            if (U.pushUnique(composedMembers, SeriesClass)) {\n                addEvent(SeriesClass, 'destroy', onSeriesDestroy);\n                addEvent(SeriesClass, 'hide', onSeriesHide);\n                const seriesProto = SeriesClass.prototype;\n                if (wglMode) {\n                    seriesProto.renderCanvas = seriesRenderCanvas;\n                }\n                wrap(seriesProto, 'getExtremes', wrapSeriesGetExtremes);\n                wrap(seriesProto, 'processData', wrapSeriesProcessData);\n                wrap(seriesProto, 'searchPoint', wrapSeriesSearchPoint);\n                [\n                    'translate',\n                    'generatePoints',\n                    'drawTracker',\n                    'drawPoints',\n                    'render'\n                ].forEach((method) => wrapSeriesFunctions(seriesProto, seriesTypes, method));\n            }\n            if (U.pushUnique(composedMembers, getOptions)) {\n                const plotOptions = getOptions().plotOptions;\n                // Set default options\n                Boostables.forEach((type) => {\n                    const typePlotOptions = plotOptions[type];\n                    if (typePlotOptions) {\n                        typePlotOptions.boostThreshold = 5000;\n                        typePlotOptions.boostData = [];\n                        seriesTypes[type].prototype.fillOpacity = true;\n                    }\n                });\n            }\n            if (wglMode) {\n                const { area: AreaSeries, areaspline: AreaSplineSeries, bubble: BubbleSeries, column: ColumnSeries, heatmap: HeatmapSeries, scatter: ScatterSeries, treemap: TreemapSeries } = seriesTypes;\n                if (AreaSeries &&\n                    U.pushUnique(composedMembers, AreaSeries)) {\n                    extend(AreaSeries.prototype, {\n                        fill: true,\n                        fillOpacity: true,\n                        sampling: true\n                    });\n                }\n                if (AreaSplineSeries &&\n                    U.pushUnique(composedMembers, AreaSplineSeries)) {\n                    extend(AreaSplineSeries.prototype, {\n                        fill: true,\n                        fillOpacity: true,\n                        sampling: true\n                    });\n                }\n                if (BubbleSeries &&\n                    U.pushUnique(composedMembers, BubbleSeries)) {\n                    const bubbleProto = BubbleSeries.prototype;\n                    // By default, the bubble series does not use the KD-tree, so force\n                    // it to.\n                    delete bubbleProto.buildKDTree;\n                    // seriesTypes.bubble.prototype.directTouch = false;\n                    // Needed for markers to work correctly\n                    wrap(bubbleProto, 'markerAttribs', function (proceed) {\n                        if (this.boosted) {\n                            return false;\n                        }\n                        return proceed.apply(this, [].slice.call(arguments, 1));\n                    });\n                }\n                if (ColumnSeries &&\n                    U.pushUnique(composedMembers, ColumnSeries)) {\n                    extend(ColumnSeries.prototype, {\n                        fill: true,\n                        sampling: true\n                    });\n                }\n                if (ScatterSeries &&\n                    U.pushUnique(composedMembers, ScatterSeries)) {\n                    ScatterSeries.prototype.fill = true;\n                }\n                // We need to handle heatmaps separatly, since we can't perform the\n                // size/color calculations in the shader easily.\n                // @todo This likely needs future optimization.\n                [HeatmapSeries, TreemapSeries].forEach((SC) => {\n                    if (SC && U.pushUnique(composedMembers, SC)) {\n                        wrap(SC.prototype, 'drawPoints', wrapSeriesDrawPoints);\n                    }\n                });\n            }\n            return SeriesClass;\n        }\n        /**\n         * Create a canvas + context and attach it to the target\n         *\n         * @private\n         * @function createAndAttachRenderer\n         *\n         * @param {Highcharts.Chart} chart\n         * the chart\n         *\n         * @param {Highcharts.Series} series\n         * the series\n         *\n         * @return {Highcharts.BoostGLRenderer}\n         * the canvas renderer\n         */\n        function createAndAttachRenderer(chart, series) {\n            const ChartClass = chart.constructor, targetGroup = chart.seriesGroup || series.group, alpha = 1;\n            let width = chart.chartWidth, height = chart.chartHeight, target = chart, foSupported = typeof SVGForeignObjectElement !== 'undefined';\n            if (isChartSeriesBoosting(chart)) {\n                target = chart;\n            }\n            else {\n                target = series;\n            }\n            const boost = target.boost =\n                target.boost ||\n                    {};\n            // Support for foreignObject is flimsy as best.\n            // IE does not support it, and Chrome has a bug which messes up\n            // the canvas draw order.\n            // As such, we force the Image fallback for now, but leaving the\n            // actual Canvas path in-place in case this changes in the future.\n            foSupported = false;\n            if (!mainCanvas) {\n                mainCanvas = doc.createElement('canvas');\n            }\n            if (!boost.target) {\n                boost.canvas = mainCanvas;\n                // Fall back to image tag if foreignObject isn't supported,\n                // or if we're exporting.\n                if (chart.renderer.forExport || !foSupported) {\n                    target.renderTarget = boost.target = chart.renderer.image('', 0, 0, width, height)\n                        .addClass('highcharts-boost-canvas')\n                        .add(targetGroup);\n                    boost.clear = function () {\n                        boost.target.attr({\n                            // Insert a blank pixel (#17182)\n                            /* eslint-disable-next-line max-len*/\n                            href: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII='\n                        });\n                    };\n                    boost.copy = function () {\n                        boost.resize();\n                        boost.target.attr({\n                            href: boost.canvas.toDataURL('image/png')\n                        });\n                    };\n                }\n                else {\n                    boost.targetFo = chart.renderer\n                        .createElement('foreignObject')\n                        .add(targetGroup);\n                    target.renderTarget = boost.target =\n                        doc.createElement('canvas');\n                    boost.targetCtx = boost.target.getContext('2d');\n                    boost.targetFo.element.appendChild(boost.target);\n                    boost.clear = function () {\n                        boost.target.width = boost.canvas.width;\n                        boost.target.height = boost.canvas.height;\n                    };\n                    boost.copy = function () {\n                        boost.target.width = boost.canvas.width;\n                        boost.target.height = boost.canvas.height;\n                        boost.targetCtx.drawImage(boost.canvas, 0, 0);\n                    };\n                }\n                boost.resize = function () {\n                    width = chart.chartWidth;\n                    height = chart.chartHeight;\n                    (boost.targetFo || boost.target)\n                        .attr({\n                        x: 0,\n                        y: 0,\n                        width,\n                        height\n                    })\n                        .css({\n                        pointerEvents: 'none',\n                        mixedBlendMode: 'normal',\n                        opacity: alpha\n                    });\n                    if (target instanceof ChartClass) {\n                        target.boost.markerGroup.translate(chart.plotLeft, chart.plotTop);\n                    }\n                };\n                boost.clipRect = chart.renderer.clipRect();\n                (boost.targetFo || boost.target)\n                    .attr({\n                    // Set the z index of the boost target to that of the last\n                    // series using it. This logic is not perfect, as it will not\n                    // handle interleaved series with boost enabled or disabled. But\n                    // it will cover the most common use case of one or more\n                    // successive boosted or non-boosted series (#9819).\n                    zIndex: series.options.zIndex\n                })\n                    .clip(boost.clipRect);\n                if (target instanceof ChartClass) {\n                    target.boost.markerGroup = target.renderer\n                        .g()\n                        .add(targetGroup)\n                        .translate(series.xAxis.pos, series.yAxis.pos);\n                }\n            }\n            boost.canvas.width = width;\n            boost.canvas.height = height;\n            if (boost.clipRect) {\n                boost.clipRect.attr(getBoostClipRect(chart, target));\n            }\n            boost.resize();\n            boost.clear();\n            if (!boost.wgl) {\n                boost.wgl = new WGLRenderer((wgl) => {\n                    if (wgl.settings.debug.timeBufferCopy) {\n                        console.time('buffer copy'); // eslint-disable-line no-console\n                    }\n                    boost.copy();\n                    if (wgl.settings.debug.timeBufferCopy) {\n                        console.timeEnd('buffer copy'); // eslint-disable-line no-console\n                    }\n                });\n                if (!boost.wgl.init(boost.canvas)) {\n                    // The OGL renderer couldn't be inited.\n                    // This likely means a shader error as we wouldn't get to this point\n                    // if there was no WebGL support.\n                    error('[highcharts boost] - unable to init WebGL renderer');\n                }\n                // target.ogl.clear();\n                boost.wgl.setOptions(chart.options.boost || {});\n                if (target instanceof ChartClass) {\n                    boost.wgl.allocateBuffer(chart);\n                }\n            }\n            boost.wgl.setSize(width, height);\n            return boost.wgl;\n        }\n        /**\n         * If implemented in the core, parts of this can probably be\n         * shared with other similar methods in Highcharts.\n         * @private\n         * @function Highcharts.Series#destroyGraphics\n         */\n        function destroyGraphics(series) {\n            const points = series.points;\n            if (points) {\n                let point, i;\n                for (i = 0; i < points.length; i = i + 1) {\n                    point = points[i];\n                    if (point && point.destroyElements) {\n                        point.destroyElements(); // #7557\n                    }\n                }\n            }\n            ['graph', 'area', 'tracker'].forEach((prop) => {\n                const seriesProp = series[prop];\n                if (seriesProp) {\n                    series[prop] = seriesProp.destroy();\n                }\n            });\n            const zonesSeries = series;\n            if (zonesSeries.getZonesGraphs) {\n                const props = zonesSeries.getZonesGraphs([['graph', 'highcharts-graph']]);\n                props.forEach((prop) => {\n                    const zoneGraph = zonesSeries[prop[0]];\n                    if (zoneGraph) {\n                        zonesSeries[prop[0]] = zoneGraph.destroy();\n                    }\n                });\n            }\n        }\n        /**\n         * An \"async\" foreach loop. Uses a setTimeout to keep the loop from blocking the\n         * UI thread.\n         *\n         * @private\n         * @param {Array<unknown>} arr\n         * The array to loop through.\n         * @param {Function} fn\n         * The callback to call for each item.\n         * @param {Function} finalFunc\n         * The callback to call when done.\n         * @param {number} [chunkSize]\n         * The number of iterations per timeout.\n         * @param {number} [i]\n         * The current index.\n         * @param {boolean} [noTimeout]\n         * Set to true to skip timeouts.\n         */\n        function eachAsync(arr, fn, finalFunc, chunkSize, i, noTimeout) {\n            i = i || 0;\n            chunkSize = chunkSize || CHUNK_SIZE;\n            const threshold = i + chunkSize;\n            let proceed = true;\n            while (proceed && i < threshold && i < arr.length) {\n                proceed = fn(arr[i], i);\n                ++i;\n            }\n            if (proceed) {\n                if (i < arr.length) {\n                    if (noTimeout) {\n                        eachAsync(arr, fn, finalFunc, chunkSize, i, noTimeout);\n                    }\n                    else if (win.requestAnimationFrame) {\n                        // If available, do requestAnimationFrame - shaves off a few ms\n                        win.requestAnimationFrame(function () {\n                            eachAsync(arr, fn, finalFunc, chunkSize, i);\n                        });\n                    }\n                    else {\n                        setTimeout(eachAsync, 0, arr, fn, finalFunc, chunkSize, i);\n                    }\n                }\n                else if (finalFunc) {\n                    finalFunc();\n                }\n            }\n        }\n        /**\n         * Enter boost mode and apply boost-specific properties.\n         * @private\n         * @function Highcharts.Series#enterBoost\n         */\n        function enterBoost(series) {\n            series.boost = series.boost || {\n                // faster than a series bind:\n                getPoint: ((bp) => getPoint(series, bp))\n            };\n            const alteredByBoost = series.boost.altered = [];\n            // Save the original values, including whether it was an own\n            // property or inherited from the prototype.\n            ['allowDG', 'directTouch', 'stickyTracking'].forEach((prop) => {\n                alteredByBoost.push({\n                    prop: prop,\n                    val: series[prop],\n                    own: Object.hasOwnProperty.call(series, prop)\n                });\n            });\n            series.allowDG = false;\n            series.directTouch = false;\n            series.stickyTracking = true;\n            // Prevent animation when zooming in on boosted series(#13421).\n            series.finishedAnimating = true;\n            // Hide series label if any\n            if (series.labelBySeries) {\n                series.labelBySeries = series.labelBySeries.destroy();\n            }\n        }\n        /**\n         * Exit from boost mode and restore non-boost properties.\n         * @private\n         * @function Highcharts.Series#exitBoost\n         */\n        function exitBoost(series) {\n            const boost = series.boost;\n            // Reset instance properties and/or delete instance properties and go back\n            // to prototype\n            if (boost) {\n                (boost.altered || []).forEach((setting) => {\n                    if (setting.own) {\n                        series[setting.prop] = setting.val;\n                    }\n                    else {\n                        // Revert to prototype\n                        delete series[setting.prop];\n                    }\n                });\n                // Clear previous run\n                if (boost.clear) {\n                    boost.clear();\n                }\n            }\n        }\n        /**\n         * @private\n         * @function Highcharts.Series#hasExtremes\n         */\n        function hasExtremes(series, checkX) {\n            const options = series.options, data = options.data, xAxis = series.xAxis && series.xAxis.options, yAxis = series.yAxis && series.yAxis.options, colorAxis = series.colorAxis && series.colorAxis.options;\n            return data.length > (options.boostThreshold || Number.MAX_VALUE) &&\n                // Defined yAxis extremes\n                isNumber(yAxis.min) &&\n                isNumber(yAxis.max) &&\n                // Defined (and required) xAxis extremes\n                (!checkX ||\n                    (isNumber(xAxis.min) && isNumber(xAxis.max))) &&\n                // Defined (e.g. heatmap) colorAxis extremes\n                (!colorAxis ||\n                    (isNumber(colorAxis.min) && isNumber(colorAxis.max)));\n        }\n        /**\n         * Extend series.destroy to also remove the fake k-d-tree points (#5137).\n         * Normally this is handled by Series.destroy that calls Point.destroy,\n         * but the fake search points are not registered like that.\n         * @private\n         */\n        function onSeriesDestroy() {\n            const series = this, chart = series.chart;\n            if (chart.boost &&\n                chart.boost.markerGroup === series.markerGroup) {\n                series.markerGroup = null;\n            }\n            if (chart.hoverPoints) {\n                chart.hoverPoints = chart.hoverPoints.filter(function (point) {\n                    return point.series === series;\n                });\n            }\n            if (chart.hoverPoint && chart.hoverPoint.series === series) {\n                chart.hoverPoint = null;\n            }\n        }\n        /**\n         * @private\n         */\n        function onSeriesHide() {\n            const boost = this.boost;\n            if (boost && boost.canvas && boost.target) {\n                if (boost.wgl) {\n                    boost.wgl.clear();\n                }\n                if (boost.clear) {\n                    boost.clear();\n                }\n            }\n        }\n        /**\n         * Performs the actual render if the renderer is\n         * attached to the series.\n         * @private\n         */\n        function renderIfNotSeriesBoosting(series) {\n            const boost = series.boost;\n            if (boost &&\n                boost.canvas &&\n                boost.target &&\n                boost.wgl &&\n                !isChartSeriesBoosting(series.chart)) {\n                boost.wgl.render(series.chart);\n            }\n        }\n        /**\n         * Return a full Point object based on the index.\n         * The boost module uses stripped point objects for performance reasons.\n\n         * @private\n         * @param {object|Highcharts.Point} boostPoint\n         *        A stripped-down point object\n         * @return {Highcharts.Point}\n         *         A Point object as per https://api.highcharts.com/highcharts#Point\n         */\n        function getPoint(series, boostPoint) {\n            const seriesOptions = series.options, xAxis = series.xAxis, PointClass = series.pointClass;\n            if (boostPoint instanceof PointClass) {\n                return boostPoint;\n            }\n            const xData = (series.xData ||\n                seriesOptions.xData ||\n                series.processedXData ||\n                false), point = (new PointClass()).init(series, series.options.data[boostPoint.i], xData ? xData[boostPoint.i] : void 0);\n            point.category = pick(xAxis.categories ?\n                xAxis.categories[point.x] :\n                point.x, // @todo simplify\n            point.x);\n            point.dist = boostPoint.dist;\n            point.distX = boostPoint.distX;\n            point.plotX = boostPoint.plotX;\n            point.plotY = boostPoint.plotY;\n            point.index = boostPoint.i;\n            point.percentage = boostPoint.percentage;\n            point.isInside = series.isPointInside(point);\n            return point;\n        }\n        /**\n         * @private\n         * @function Highcharts.Series#renderCanvas\n         */\n        function seriesRenderCanvas() {\n            const options = this.options || {}, chart = this.chart, xAxis = this.xAxis, yAxis = this.yAxis, xData = options.xData || this.processedXData, yData = options.yData || this.processedYData, rawData = options.data, xExtremes = xAxis.getExtremes(), xMin = xExtremes.min, xMax = xExtremes.max, yExtremes = yAxis.getExtremes(), yMin = yExtremes.min, yMax = yExtremes.max, pointTaken = {}, sampling = !!this.sampling, enableMouseTracking = options.enableMouseTracking, threshold = options.threshold, isRange = this.pointArrayMap &&\n                this.pointArrayMap.join(',') === 'low,high', isStacked = !!options.stacking, cropStart = this.cropStart || 0, requireSorting = this.requireSorting, useRaw = !xData, compareX = options.findNearestPointBy === 'x', xDataFull = (this.xData ||\n                this.options.xData ||\n                this.processedXData ||\n                false);\n            let renderer = false, lastClientX, yBottom = yAxis.getThreshold(threshold), minVal, maxVal, minI, maxI;\n            // Get or create the renderer\n            renderer = createAndAttachRenderer(chart, this);\n            chart.boosted = true;\n            if (!this.visible) {\n                return;\n            }\n            // If we are zooming out from SVG mode, destroy the graphics\n            if (this.points || this.graph) {\n                destroyGraphics(this);\n            }\n            // If we're rendering per. series we should create the marker groups\n            // as usual.\n            if (!isChartSeriesBoosting(chart)) {\n                // If all series were boosting, but are not anymore\n                // restore private markerGroup\n                if (chart.boost &&\n                    this.markerGroup === chart.boost.markerGroup) {\n                    this.markerGroup = void 0;\n                }\n                this.markerGroup = this.plotGroup('markerGroup', 'markers', true, 1, chart.seriesGroup);\n            }\n            else {\n                // If series has a private markeGroup, remove that\n                // and use common markerGroup\n                if (this.markerGroup &&\n                    this.markerGroup !== chart.boost.markerGroup) {\n                    this.markerGroup.destroy();\n                }\n                // Use a single group for the markers\n                this.markerGroup = chart.boost.markerGroup;\n                // When switching from chart boosting mode, destroy redundant\n                // series boosting targets\n                if (this.boost && this.boost.target) {\n                    this.renderTarget = this.boost.target = this.boost.target.destroy();\n                }\n            }\n            const points = this.points = [], addKDPoint = (clientX, plotY, i, percentage) => {\n                const x = xDataFull ? xDataFull[cropStart + i] : false, pushPoint = (plotX) => {\n                    if (chart.inverted) {\n                        plotX = xAxis.len - plotX;\n                        plotY = yAxis.len - plotY;\n                    }\n                    points.push({\n                        destroy: noop,\n                        x: x,\n                        clientX: plotX,\n                        plotX: plotX,\n                        plotY: plotY,\n                        i: cropStart + i,\n                        percentage: percentage\n                    });\n                };\n                // We need to do ceil on the clientX to make things\n                // snap to pixel values. The renderer will frequently\n                // draw stuff on \"sub-pixels\".\n                clientX = Math.ceil(clientX);\n                // Shaves off about 60ms compared to repeated concatenation\n                index = compareX ? clientX : clientX + ',' + plotY;\n                // The k-d tree requires series points.\n                // Reduce the amount of points, since the time to build the\n                // tree increases exponentially.\n                if (enableMouseTracking) {\n                    if (!pointTaken[index]) {\n                        pointTaken[index] = true;\n                        pushPoint(clientX);\n                    }\n                    else if (x === xDataFull[xDataFull.length - 1]) {\n                        // If the last point is on the same pixel as the last\n                        // tracked point, swap them. (#18856)\n                        points.length--;\n                        pushPoint(clientX);\n                    }\n                }\n            };\n            // Do not start building while drawing\n            this.buildKDTree = noop;\n            if (renderer) {\n                allocateIfNotSeriesBoosting(renderer, this);\n                renderer.pushSeries(this);\n                // Perform the actual renderer if we're on series level\n                renderIfNotSeriesBoosting(this);\n            }\n            /**\n             * This builds the KD-tree\n             * @private\n             */\n            function processPoint(d, i) {\n                const chartDestroyed = typeof chart.index === 'undefined';\n                let x, y, clientX, plotY, percentage, low = false, isYInside = true;\n                if (!defined(d)) {\n                    return true;\n                }\n                if (!chartDestroyed) {\n                    if (useRaw) {\n                        x = d[0];\n                        y = d[1];\n                    }\n                    else {\n                        x = d;\n                        y = yData[i];\n                    }\n                    // Resolve low and high for range series\n                    if (isRange) {\n                        if (useRaw) {\n                            y = d.slice(1, 3);\n                        }\n                        low = y[0];\n                        y = y[1];\n                    }\n                    else if (isStacked) {\n                        x = d.x;\n                        y = d.stackY;\n                        low = y - d.y;\n                        percentage = d.percentage;\n                    }\n                    // Optimize for scatter zooming\n                    if (!requireSorting) {\n                        isYInside = (y || 0) >= yMin && y <= yMax;\n                    }\n                    if (y !== null && x >= xMin && x <= xMax && isYInside) {\n                        clientX = xAxis.toPixels(x, true);\n                        if (sampling) {\n                            if (typeof minI === 'undefined' ||\n                                clientX === lastClientX) {\n                                if (!isRange) {\n                                    low = y;\n                                }\n                                if (typeof maxI === 'undefined' ||\n                                    y > maxVal) {\n                                    maxVal = y;\n                                    maxI = i;\n                                }\n                                if (typeof minI === 'undefined' ||\n                                    low < minVal) {\n                                    minVal = low;\n                                    minI = i;\n                                }\n                            }\n                            // Add points and reset\n                            if (!compareX || clientX !== lastClientX) {\n                                // maxI is number too:\n                                if (typeof minI !== 'undefined') {\n                                    plotY =\n                                        yAxis.toPixels(maxVal, true);\n                                    yBottom =\n                                        yAxis.toPixels(minVal, true);\n                                    addKDPoint(clientX, plotY, maxI, percentage);\n                                    if (yBottom !== plotY) {\n                                        addKDPoint(clientX, yBottom, minI, percentage);\n                                    }\n                                }\n                                minI = maxI = void 0;\n                                lastClientX = clientX;\n                            }\n                        }\n                        else {\n                            plotY = Math.ceil(yAxis.toPixels(y, true));\n                            addKDPoint(clientX, plotY, i, percentage);\n                        }\n                    }\n                }\n                return !chartDestroyed;\n            }\n            /**\n             * @private\n             */\n            const boostOptions = renderer.settings, doneProcessing = () => {\n                fireEvent(this, 'renderedCanvas');\n                // Go back to prototype, ready to build\n                delete this.buildKDTree;\n                this.buildKDTree();\n                if (boostOptions.debug.timeKDTree) {\n                    console.timeEnd('kd tree building'); // eslint-disable-line no-console\n                }\n            };\n            // Loop over the points to build the k-d tree - skip this if\n            // exporting\n            if (!chart.renderer.forExport) {\n                if (boostOptions.debug.timeKDTree) {\n                    console.time('kd tree building'); // eslint-disable-line no-console\n                }\n                eachAsync(isStacked ? this.data : (xData || rawData), processPoint, doneProcessing);\n            }\n        }\n        /**\n         * Used for treemap|heatmap.drawPoints\n         * @private\n         */\n        function wrapSeriesDrawPoints(proceed) {\n            let enabled = true;\n            if (this.chart.options && this.chart.options.boost) {\n                enabled = typeof this.chart.options.boost.enabled === 'undefined' ?\n                    true :\n                    this.chart.options.boost.enabled;\n            }\n            if (!enabled || !this.boosted) {\n                return proceed.call(this);\n            }\n            this.chart.boosted = true;\n            // Make sure we have a valid OGL context\n            const renderer = createAndAttachRenderer(this.chart, this);\n            if (renderer) {\n                allocateIfNotSeriesBoosting(renderer, this);\n                renderer.pushSeries(this);\n            }\n            renderIfNotSeriesBoosting(this);\n        }\n        /**\n         * Override a bunch of methods the same way. If the number of points is\n         * below the threshold, run the original method. If not, check for a\n         * canvas version or do nothing.\n         *\n         * Note that we're not overriding any of these for heatmaps.\n         */\n        function wrapSeriesFunctions(seriesProto, seriesTypes, method) {\n            /**\n             * @private\n             */\n            function branch(proceed) {\n                const letItPass = this.options.stacking &&\n                    (method === 'translate' || method === 'generatePoints');\n                if (!this.boosted ||\n                    letItPass ||\n                    !boostEnabled(this.chart) ||\n                    this.type === 'heatmap' ||\n                    this.type === 'treemap' ||\n                    !BoostableMap[this.type] ||\n                    this.options.boostThreshold === 0) {\n                    proceed.call(this);\n                    // Run canvas version of method, like renderCanvas(), if it exists\n                }\n                else if (method === 'render' && this.renderCanvas) {\n                    this.renderCanvas();\n                }\n            }\n            wrap(seriesProto, method, branch);\n            // Special case for some types, when translate method is already wrapped\n            if (method === 'translate') {\n                [\n                    'column',\n                    'arearange',\n                    'columnrange',\n                    'heatmap',\n                    'treemap'\n                ].forEach(function (type) {\n                    if (seriesTypes[type]) {\n                        wrap(seriesTypes[type].prototype, method, branch);\n                    }\n                });\n            }\n        }\n        /**\n         * Do not compute extremes when min and max are set. If we use this in the\n         * core, we can add the hook to hasExtremes to the methods directly.\n         * @private\n         */\n        function wrapSeriesGetExtremes(proceed) {\n            if (this.boosted &&\n                hasExtremes(this)) {\n                return {};\n            }\n            return proceed.apply(this, [].slice.call(arguments, 1));\n        }\n        /**\n         * If the series is a heatmap or treemap, or if the series is not boosting\n         * do the default behaviour. Otherwise, process if the series has no\n         * extremes.\n         * @private\n         */\n        function wrapSeriesProcessData(proceed) {\n            let dataToMeasure = this.options.data;\n            /**\n             * Used twice in this function, first on this.options.data, the second\n             * time it runs the check again after processedXData is built.\n             * If the data is going to be grouped, the series shouldn't be boosted.\n             * @private\n             */\n            const getSeriesBoosting = (data) => {\n                const series = this;\n                // Check if will be grouped.\n                if (series.forceCrop) {\n                    return false;\n                }\n                return (isChartSeriesBoosting(series.chart) ||\n                    ((data ? data.length : 0) >=\n                        (series.options.boostThreshold || Number.MAX_VALUE)));\n            };\n            if (boostEnabled(this.chart) && BoostableMap[this.type]) {\n                const series = this;\n                // If there are no extremes given in the options, we also need to\n                // process the data to read the data extremes. If this is a heatmap,\n                // do default behaviour.\n                if (\n                // First pass with options.data:\n                !getSeriesBoosting(dataToMeasure) ||\n                    series.type === 'heatmap' ||\n                    series.type === 'treemap' ||\n                    // processedYData for the stack (#7481):\n                    series.options.stacking ||\n                    !hasExtremes(series, true)) {\n                    proceed.apply(series, [].slice.call(arguments, 1));\n                    dataToMeasure = series.processedXData;\n                }\n                // Set the isBoosting flag, second pass with processedXData to\n                // see if we have zoomed.\n                series.boosted = getSeriesBoosting(dataToMeasure);\n                // Enter or exit boost mode\n                if (series.boosted) {\n                    // Force turbo-mode:\n                    let firstPoint;\n                    if (series.options.data &&\n                        series.options.data.length) {\n                        firstPoint = series.getFirstValidPoint(series.options.data);\n                        if (!isNumber(firstPoint) && !isArray(firstPoint)) {\n                            error(12, false, series.chart);\n                        }\n                    }\n                    enterBoost(series);\n                }\n                else {\n                    exitBoost(series);\n                }\n                // The series type is not boostable\n            }\n            else {\n                proceed.apply(this, [].slice.call(arguments, 1));\n            }\n        }\n        /**\n         * Return a point instance from the k-d-tree\n         * @private\n         */\n        function wrapSeriesSearchPoint(proceed) {\n            const result = proceed.apply(this, [].slice.call(arguments, 1));\n            if (this.boost && result) {\n                return this.boost.getPoint(result);\n            }\n            return result;\n        }\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        const BoostSeries = {\n            compose,\n            destroyGraphics,\n            eachAsync,\n            getPoint\n        };\n\n        return BoostSeries;\n    });\n    _registerModule(_modules, 'Extensions/BoostCanvas.js', [_modules['Extensions/Boost/BoostChart.js'], _modules['Extensions/Boost/BoostSeries.js'], _modules['Core/Chart/Chart.js'], _modules['Core/Color/Color.js'], _modules['Core/Globals.js'], _modules['Core/Utilities.js']], function (BoostChart, BoostSeries, Chart, Color, H, U) {\n        /* *\n         *\n         *  License: www.highcharts.com/license\n         *  Author: Torstein Honsi, Christer Vasseng\n         *\n         *  This module serves as a fallback for the Boost module in IE9 and IE10. Newer\n         *  browsers support WebGL which is faster.\n         *\n         *  It is recommended to include this module in conditional comments targeting\n         *  IE9 and IE10.\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { getBoostClipRect, isChartSeriesBoosting } = BoostChart;\n        const { destroyGraphics } = BoostSeries;\n        const { parse: color } = Color;\n        const { doc, noop } = H;\n        const { addEvent, fireEvent, isNumber, merge, pick, pushUnique, wrap } = U;\n        /* *\n         *\n         *  Namespace\n         *\n         * */\n        var BoostCanvas;\n        (function (BoostCanvas) {\n            /* *\n             *\n             *  Constants\n             *\n             * */\n            // Use a blank pixel for clearing canvas (#17182)\n            const b64BlankPixel = ('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAw' +\n                'CAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII=');\n            const CHUNK_SIZE = 50000;\n            const composedMembers = [];\n            /* *\n             *\n             *  Variables\n             *\n             * */\n            let destroyLoadingDiv;\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * @private\n             */\n            function areaCvsDrawPoint(ctx, clientX, plotY, yBottom, lastPoint) {\n                if (lastPoint && clientX !== lastPoint.clientX) {\n                    ctx.moveTo(lastPoint.clientX, lastPoint.yBottom);\n                    ctx.lineTo(lastPoint.clientX, lastPoint.plotY);\n                    ctx.lineTo(clientX, plotY);\n                    ctx.lineTo(clientX, yBottom);\n                }\n            }\n            /**\n             * @private\n             */\n            function bubbleCvsMarkerCircle(ctx, clientX, plotY, r, i) {\n                ctx.moveTo(clientX, plotY);\n                ctx.arc(clientX, plotY, this.radii && this.radii[i], 0, 2 * Math.PI, false);\n            }\n            /**\n             * @private\n             */\n            function columnCvsDrawPoint(ctx, clientX, plotY, yBottom) {\n                ctx.rect(clientX - 1, plotY, 1, yBottom - plotY);\n            }\n            /**\n             * @private\n             */\n            function compose(ChartClass, SeriesClass, seriesTypes) {\n                if (pushUnique(composedMembers, ChartClass)) {\n                    Chart.prototype.callbacks.push((chart) => {\n                        addEvent(chart, 'predraw', onChartClear);\n                        addEvent(chart, 'render', onChartCanvasToSVG);\n                    });\n                }\n                if (pushUnique(composedMembers, SeriesClass)) {\n                    const seriesProto = SeriesClass.prototype;\n                    seriesProto.canvasToSVG = seriesCanvasToSVG;\n                    seriesProto.cvsLineTo = seriesCvsLineTo;\n                    seriesProto.getContext = seriesGetContext;\n                    seriesProto.renderCanvas = seriesRenderCanvas;\n                }\n                const { area: AreaSeries, bubble: BubbleSeries, column: ColumnSeries, heatmap: HeatmapSeries, scatter: ScatterSeries } = seriesTypes;\n                if (AreaSeries &&\n                    pushUnique(composedMembers, AreaSeries)) {\n                    const areaProto = AreaSeries.prototype;\n                    areaProto.cvsDrawPoint = areaCvsDrawPoint;\n                    areaProto.fill = true;\n                    areaProto.fillOpacity = true;\n                    areaProto.sampling = true;\n                }\n                if (BubbleSeries &&\n                    pushUnique(composedMembers, BubbleSeries)) {\n                    const bubbleProto = BubbleSeries.prototype;\n                    bubbleProto.cvsMarkerCircle = bubbleCvsMarkerCircle;\n                    bubbleProto.cvsStrokeBatch = 1;\n                }\n                if (ColumnSeries &&\n                    pushUnique(composedMembers, ColumnSeries)) {\n                    const columnProto = ColumnSeries.prototype;\n                    columnProto.cvsDrawPoint = columnCvsDrawPoint;\n                    columnProto.fill = true;\n                    columnProto.sampling = true;\n                }\n                if (HeatmapSeries &&\n                    pushUnique(composedMembers, HeatmapSeries)) {\n                    const heatmapProto = HeatmapSeries.prototype;\n                    wrap(heatmapProto, 'drawPoints', wrapHeatmapDrawPoints);\n                }\n                if (ScatterSeries &&\n                    pushUnique(composedMembers, ScatterSeries)) {\n                    const scatterProto = ScatterSeries.prototype;\n                    scatterProto.cvsMarkerCircle = scatterCvsMarkerCircle;\n                    scatterProto.cvsMarkerSquare = scatterCvsMarkerSquare;\n                    scatterProto.fill = true;\n                }\n            }\n            BoostCanvas.compose = compose;\n            /**\n             * @private\n             */\n            function onChartCanvasToSVG() {\n                if (this.boost && this.boost.copy) {\n                    this.boost.copy();\n                }\n            }\n            /**\n             * @private\n             */\n            function onChartClear() {\n                const boost = this.boost || {};\n                if (boost.target) {\n                    boost.target.attr({ href: b64BlankPixel });\n                }\n                if (boost.canvas) {\n                    boost.canvas.getContext('2d').clearRect(0, 0, boost.canvas.width, boost.canvas.height);\n                }\n            }\n            /**\n             * Draw the canvas image inside an SVG image\n             *\n             * @private\n             * @function Highcharts.Series#canvasToSVG\n             */\n            function seriesCanvasToSVG() {\n                if (!isChartSeriesBoosting(this.chart)) {\n                    if (this.boost && this.boost.copy) {\n                        this.boost.copy();\n                    }\n                    else if (this.chart.boost && this.chart.boost.copy) {\n                        this.chart.boost.copy();\n                    }\n                }\n                else if (this.boost && this.boost.clear) {\n                    this.boost.clear();\n                }\n            }\n            /**\n             * @private\n             */\n            function seriesCvsLineTo(ctx, clientX, plotY) {\n                ctx.lineTo(clientX, plotY);\n            }\n            /**\n             * Create a hidden canvas to draw the graph on. The contents is later\n             * copied over to an SVG image element.\n             *\n             * @private\n             * @function Highcharts.Series#getContext\n             */\n            function seriesGetContext() {\n                const chart = this.chart, target = isChartSeriesBoosting(chart) ? chart : this, targetGroup = (target === chart ?\n                    chart.seriesGroup :\n                    chart.seriesGroup || this.group), width = chart.chartWidth, height = chart.chartHeight, swapXY = function (proceed, x, y, a, b, c, d) {\n                    proceed.call(this, y, x, a, b, c, d);\n                };\n                let ctx;\n                const boost = target.boost =\n                    target.boost ||\n                        {};\n                ctx = boost.targetCtx;\n                if (!boost.canvas) {\n                    boost.canvas = doc.createElement('canvas');\n                    boost.target = chart.renderer\n                        .image('', 0, 0, width, height)\n                        .addClass('highcharts-boost-canvas')\n                        .add(targetGroup);\n                    ctx = boost.targetCtx =\n                        boost.canvas.getContext('2d');\n                    if (chart.inverted) {\n                        ['moveTo', 'lineTo', 'rect', 'arc'].forEach((fn) => {\n                            wrap(ctx, fn, swapXY);\n                        });\n                    }\n                    boost.copy = function () {\n                        boost.target.attr({\n                            href: boost.canvas.toDataURL('image/png')\n                        });\n                    };\n                    boost.clear = function () {\n                        ctx.clearRect(0, 0, boost.canvas.width, boost.canvas.height);\n                        if (target === boost.target) {\n                            boost.target.attr({\n                                href: b64BlankPixel\n                            });\n                        }\n                    };\n                    boost.clipRect = chart.renderer.clipRect();\n                    boost.target.clip(boost.clipRect);\n                }\n                else if (!(target instanceof Chart)) {\n                    // ctx.clearRect(0, 0, width, height);\n                }\n                if (boost.canvas.width !== width) {\n                    boost.canvas.width = width;\n                }\n                if (boost.canvas.height !== height) {\n                    boost.canvas.height = height;\n                }\n                boost.target.attr({\n                    x: 0,\n                    y: 0,\n                    width: width,\n                    height: height,\n                    style: 'pointer-events: none',\n                    href: b64BlankPixel\n                });\n                if (boost.clipRect) {\n                    boost.clipRect.attr(getBoostClipRect(chart, target));\n                }\n                return ctx;\n            }\n            /**\n             * @private\n             */\n            function seriesRenderCanvas() {\n                const series = this, options = series.options, chart = series.chart, xAxis = series.xAxis, yAxis = series.yAxis, activeBoostSettings = chart.options.boost || {}, boostSettings = {\n                    timeRendering: activeBoostSettings.timeRendering || false,\n                    timeSeriesProcessing: activeBoostSettings.timeSeriesProcessing || false,\n                    timeSetup: activeBoostSettings.timeSetup || false\n                }, xData = series.processedXData, yData = series.processedYData, rawData = options.data, xExtremes = xAxis.getExtremes(), xMin = xExtremes.min, xMax = xExtremes.max, yExtremes = yAxis.getExtremes(), yMin = yExtremes.min, yMax = yExtremes.max, pointTaken = {}, sampling = !!series.sampling, r = options.marker && options.marker.radius, strokeBatch = series.cvsStrokeBatch || 1000, enableMouseTracking = options.enableMouseTracking, threshold = options.threshold, hasThreshold = isNumber(threshold), translatedThreshold = yAxis.getThreshold(threshold), doFill = series.fill, isRange = (series.pointArrayMap &&\n                    series.pointArrayMap.join(',') === 'low,high'), isStacked = !!options.stacking, cropStart = series.cropStart || 0, loadingOptions = chart.options.loading, requireSorting = series.requireSorting, connectNulls = options.connectNulls, useRaw = !xData, sdata = (isStacked ?\n                    series.data :\n                    (xData || rawData)), fillColor = (series.fillOpacity ?\n                    Color.parse(series.color).setOpacity(pick(options.fillOpacity, 0.75)).get() :\n                    series.color), compareX = options.findNearestPointBy === 'x', boost = this.boost || {}, cvsDrawPoint = series.cvsDrawPoint, cvsLineTo = options.lineWidth ? series.cvsLineTo : void 0, cvsMarker = (r && r <= 1 ?\n                    series.cvsMarkerSquare :\n                    series.cvsMarkerCircle);\n                if (boost.target) {\n                    boost.target.attr({ href: b64BlankPixel });\n                }\n                // If we are zooming out from SVG mode, destroy the graphics\n                if (series.points || series.graph) {\n                    destroyGraphics(series);\n                }\n                // The group\n                series.plotGroup('group', 'series', series.visible ? 'visible' : 'hidden', options.zIndex, chart.seriesGroup);\n                series.markerGroup = series.group;\n                addEvent(series, 'destroy', function () {\n                    // Prevent destroy twice\n                    series.markerGroup = null;\n                });\n                const points = this.points = [], ctx = this.getContext();\n                series.buildKDTree = noop; // Do not start building while drawing\n                if (boost.clear) {\n                    boost.clear();\n                }\n                // if (series.canvas) {\n                //     ctx.clearRect(\n                //         0,\n                //         0,\n                //         series.canvas.width,\n                //         series.canvas.height\n                //     );\n                // }\n                if (!series.visible) {\n                    return;\n                }\n                // Display a loading indicator\n                if (rawData.length > 99999) {\n                    chart.options.loading = merge(loadingOptions, {\n                        labelStyle: {\n                            backgroundColor: color(\"#ffffff\" /* Palette.backgroundColor */).setOpacity(0.75).get(),\n                            padding: '1em',\n                            borderRadius: '0.5em'\n                        },\n                        style: {\n                            backgroundColor: 'none',\n                            opacity: 1\n                        }\n                    });\n                    U.clearTimeout(destroyLoadingDiv);\n                    chart.showLoading('Drawing...');\n                    chart.options.loading = loadingOptions; // reset\n                }\n                if (boostSettings.timeRendering) {\n                    console.time('canvas rendering'); // eslint-disable-line no-console\n                }\n                // Loop variables\n                let c = 0, lastClientX, lastPoint, yBottom = translatedThreshold, wasNull, minVal, maxVal, minI, maxI, index;\n                // Loop helpers\n                const stroke = function () {\n                    if (doFill) {\n                        ctx.fillStyle = fillColor;\n                        ctx.fill();\n                    }\n                    else {\n                        ctx.strokeStyle = series.color;\n                        ctx.lineWidth = options.lineWidth;\n                        ctx.stroke();\n                    }\n                }, \n                //\n                drawPoint = function (clientX, plotY, yBottom, i) {\n                    if (c === 0) {\n                        ctx.beginPath();\n                        if (cvsLineTo) {\n                            ctx.lineJoin = 'round';\n                        }\n                    }\n                    if (chart.scroller &&\n                        series.options.className ===\n                            'highcharts-navigator-series') {\n                        plotY += chart.scroller.top;\n                        if (yBottom) {\n                            yBottom += chart.scroller.top;\n                        }\n                    }\n                    else {\n                        plotY += chart.plotTop;\n                    }\n                    clientX += chart.plotLeft;\n                    if (wasNull) {\n                        ctx.moveTo(clientX, plotY);\n                    }\n                    else {\n                        if (cvsDrawPoint) {\n                            cvsDrawPoint(ctx, clientX, plotY, yBottom, lastPoint);\n                        }\n                        else if (cvsLineTo) {\n                            cvsLineTo(ctx, clientX, plotY);\n                        }\n                        else if (cvsMarker) {\n                            cvsMarker.call(series, ctx, clientX, plotY, r, i);\n                        }\n                    }\n                    // We need to stroke the line for every 1000 pixels. It will\n                    // crash the browser memory use if we stroke too\n                    // infrequently.\n                    c = c + 1;\n                    if (c === strokeBatch) {\n                        stroke();\n                        c = 0;\n                    }\n                    // Area charts need to keep track of the last point\n                    lastPoint = {\n                        clientX: clientX,\n                        plotY: plotY,\n                        yBottom: yBottom\n                    };\n                }, xDataFull = (this.xData ||\n                    this.options.xData ||\n                    this.processedXData ||\n                    false), \n                //\n                addKDPoint = function (clientX, plotY, i) {\n                    // Shaves off about 60ms compared to repeated concatenation\n                    index = compareX ? clientX : clientX + ',' + plotY;\n                    // The k-d tree requires series points.\n                    // Reduce the amount of points, since the time to build the\n                    // tree increases exponentially.\n                    if (enableMouseTracking && !pointTaken[index]) {\n                        pointTaken[index] = true;\n                        if (chart.inverted) {\n                            clientX = xAxis.len - clientX;\n                            plotY = yAxis.len - plotY;\n                        }\n                        points.push({\n                            x: xDataFull ?\n                                xDataFull[cropStart + i] :\n                                false,\n                            clientX: clientX,\n                            plotX: clientX,\n                            plotY: plotY,\n                            i: cropStart + i\n                        });\n                    }\n                };\n                // Loop over the points\n                BoostSeries.eachAsync(sdata, (d, i) => {\n                    const chartDestroyed = typeof chart.index === 'undefined';\n                    let x, y, clientX, plotY, isNull, low, isNextInside = false, isPrevInside = false, nx = NaN, px = NaN, isYInside = true;\n                    if (!chartDestroyed) {\n                        if (useRaw) {\n                            x = d[0];\n                            y = d[1];\n                            if (sdata[i + 1]) {\n                                nx = sdata[i + 1][0];\n                            }\n                            if (sdata[i - 1]) {\n                                px = sdata[i - 1][0];\n                            }\n                        }\n                        else {\n                            x = d;\n                            y = yData[i];\n                            if (sdata[i + 1]) {\n                                nx = sdata[i + 1];\n                            }\n                            if (sdata[i - 1]) {\n                                px = sdata[i - 1];\n                            }\n                        }\n                        if (nx && nx >= xMin && nx <= xMax) {\n                            isNextInside = true;\n                        }\n                        if (px && px >= xMin && px <= xMax) {\n                            isPrevInside = true;\n                        }\n                        // Resolve low and high for range series\n                        if (isRange) {\n                            if (useRaw) {\n                                y = d.slice(1, 3);\n                            }\n                            low = y[0];\n                            y = y[1];\n                        }\n                        else if (isStacked) {\n                            x = d.x;\n                            y = d.stackY;\n                            low = y - d.y;\n                        }\n                        isNull = y === null;\n                        // Optimize for scatter zooming\n                        if (!requireSorting) {\n                            isYInside = y >= yMin && y <= yMax;\n                        }\n                        if (!isNull &&\n                            ((x >= xMin && x <= xMax && isYInside) ||\n                                (isNextInside || isPrevInside))) {\n                            clientX = Math.round(xAxis.toPixels(x, true));\n                            if (sampling) {\n                                if (typeof minI === 'undefined' ||\n                                    clientX === lastClientX) {\n                                    if (!isRange) {\n                                        low = y;\n                                    }\n                                    if (typeof maxI === 'undefined' || y > maxVal) {\n                                        maxVal = y;\n                                        maxI = i;\n                                    }\n                                    if (typeof minI === 'undefined' ||\n                                        low < minVal) {\n                                        minVal = low;\n                                        minI = i;\n                                    }\n                                }\n                                // Add points and reset\n                                if (clientX !== lastClientX) {\n                                    // maxI also a number:\n                                    if (typeof minI !== 'undefined') {\n                                        plotY = yAxis.toPixels(maxVal, true);\n                                        yBottom = yAxis.toPixels(minVal, true);\n                                        drawPoint(clientX, hasThreshold ?\n                                            Math.min(plotY, translatedThreshold) : plotY, hasThreshold ?\n                                            Math.max(yBottom, translatedThreshold) : yBottom, i);\n                                        addKDPoint(clientX, plotY, maxI);\n                                        if (yBottom !== plotY) {\n                                            addKDPoint(clientX, yBottom, minI);\n                                        }\n                                    }\n                                    minI = maxI = void 0;\n                                    lastClientX = clientX;\n                                }\n                            }\n                            else {\n                                plotY = Math.round(yAxis.toPixels(y, true));\n                                drawPoint(clientX, plotY, yBottom, i);\n                                addKDPoint(clientX, plotY, i);\n                            }\n                        }\n                        wasNull = isNull && !connectNulls;\n                        if (i % CHUNK_SIZE === 0) {\n                            if (series.boost &&\n                                series.boost.copy) {\n                                series.boost.copy();\n                            }\n                            else if (series.chart.boost &&\n                                series.chart.boost.copy) {\n                                series.chart.boost.copy();\n                            }\n                        }\n                    }\n                    return !chartDestroyed;\n                }, function () {\n                    const loadingDiv = chart.loadingDiv, loadingShown = chart.loadingShown;\n                    stroke();\n                    // if (series.boostCopy || series.chart.boostCopy) {\n                    //     (series.boostCopy || series.chart.boostCopy)();\n                    // }\n                    series.canvasToSVG();\n                    if (boostSettings.timeRendering) {\n                        console.timeEnd('canvas rendering'); // eslint-disable-line no-console\n                    }\n                    fireEvent(series, 'renderedCanvas');\n                    // Do not use chart.hideLoading, as it runs JS animation and\n                    // will be blocked by buildKDTree. CSS animation looks good, but\n                    // then it must be deleted in timeout. If we add the module to\n                    // core, change hideLoading so we can skip this block.\n                    if (loadingShown) {\n                        loadingDiv.style.transition = 'opacity 250ms';\n                        loadingDiv.opacity = 0;\n                        chart.loadingShown = false;\n                        destroyLoadingDiv = setTimeout(function () {\n                            if (loadingDiv.parentNode) { // In exporting it is falsy\n                                loadingDiv.parentNode.removeChild(loadingDiv);\n                            }\n                            chart.loadingDiv = chart.loadingSpan = null;\n                        }, 250);\n                    }\n                    // Go back to prototype, ready to build\n                    delete series.buildKDTree;\n                    series.buildKDTree();\n                    // Don't do async on export, the exportChart, getSVGForExport and\n                    // getSVG methods are not chained for it.\n                }, chart.renderer.forExport ? Number.MAX_VALUE : void 0);\n            }\n            /**\n             * @private\n             */\n            function scatterCvsMarkerCircle(ctx, clientX, plotY, r) {\n                ctx.moveTo(clientX, plotY);\n                ctx.arc(clientX, plotY, r, 0, 2 * Math.PI, false);\n            }\n            /**\n             * Rect is twice as fast as arc, should be used for small markers.\n             * @private\n             */\n            function scatterCvsMarkerSquare(ctx, clientX, plotY, r) {\n                ctx.rect(clientX - r, plotY - r, r * 2, r * 2);\n            }\n            /**\n             * @private\n             */\n            function wrapHeatmapDrawPoints() {\n                const chart = this.chart, ctx = this.getContext(), inverted = this.chart.inverted, xAxis = this.xAxis, yAxis = this.yAxis;\n                if (ctx) {\n                    // Draw the columns\n                    this.points.forEach((point) => {\n                        let plotY = point.plotY, pointAttr;\n                        if (typeof plotY !== 'undefined' &&\n                            !isNaN(plotY) &&\n                            point.y !== null &&\n                            ctx) {\n                            const { x = 0, y = 0, width = 0, height = 0 } = point.shapeArgs || {};\n                            if (!chart.styledMode) {\n                                pointAttr = point.series.pointAttribs(point);\n                            }\n                            else {\n                                pointAttr = point.series.colorAttribs(point);\n                            }\n                            ctx.fillStyle = pointAttr.fill;\n                            if (inverted) {\n                                ctx.fillRect(yAxis.len - y + xAxis.left, xAxis.len - x + yAxis.top, -height, -width);\n                            }\n                            else {\n                                ctx.fillRect(x + xAxis.left, y + yAxis.top, width, height);\n                            }\n                        }\n                    });\n                    this.canvasToSVG();\n                }\n                else {\n                    this.chart.showLoading('Your browser doesn\\'t support HTML5 canvas, <br>' +\n                        'please use a modern browser');\n                }\n            }\n        })(BoostCanvas || (BoostCanvas = {}));\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return BoostCanvas;\n    });\n    _registerModule(_modules, 'masters/modules/boost-canvas.src.js', [_modules['Core/Globals.js'], _modules['Extensions/BoostCanvas.js']], function (Highcharts, BoostCanvas) {\n\n        const G = Highcharts;\n        /**\n         * Initialize the canvas boost.\n         *\n         * @function Highcharts.initCanvasBoost\n         */\n        G.initCanvasBoost = function () {\n            BoostCanvas.compose(G.Chart, G.Series, G.seriesTypes);\n        };\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","Boostables","BoostableMap","forEach","item","U","addEvent","pick","composedClasses","isChartSeriesBoosting","chart","allSeries","series","boost","boostOptions","options","threshold","seriesThreshold","length","allowBoostForce","allowForce","axis","xAxis","min","Infinity","dataMin","max","dataMax","forceChartBoost","canBoostCount","needBoostCount","seriesOptions","boostThreshold","visible","type","patientMax","r","Number","MAX_VALUE","t","processedXData","data","points","onChartCallback","boosted","clear","canvas","wgl","allocateBuffer","markerGroup","yAxis","translate","pos","render","prevX","prevY","pointer","hoverSeries","inverted","compose","ChartClass","wglMode","pushUnique","prototype","callbacks","push","getBoostClipRect","target","clipBox","x","plotLeft","y","plotTop","width","plotWidth","height","navigator","top","plotHeight","getClipBox","lateral","verticalAxes","Math","len","clamp","error","constructor","gl","errors","uLocations","createShader","bind","shaderProgram","useProgram","v","stringToProgram","f","uloc","n","getUniformLocation","createProgram","attachShader","linkProgram","getProgramParameter","LINK_STATUS","bindAttribLocation","pUniform","psUniform","fcUniform","isBubbleUniform","bubbleSizeAbsUniform","bubbleSizeAreaUniform","uSamplerUniform","skipTranslationUniform","isCircleUniform","isInverted","getProgramInfoLog","handleErrors","join","str","shader","VERTEX_SHADER","FRAGMENT_SHADER","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","destroy","deleteProgram","fillColorUniform","getProgram","pointSizeUniform","perspectiveUniform","reset","uniform1i","setBubbleUniforms","zCalcMin","zCalcMax","pixelRatio","zMin","zMax","is","pxSizes","getPxExtremes","displayNegative","zThreshold","sizeBy","sizeByAbsoluteValue","setUniform","minPxSize","maxPxSize","setColor","color","uniform4f","setDrawAsCircle","flag","setInverted","setPMatrix","m","uniformMatrix4fv","setPointSize","p","uniform1f","setSkipTranslation","setTexture","texture","name","val","u","dataComponents","buffer","iterator","preAllocated","vertAttribute","components","allocate","size","Float32Array","vertexAttribPointer","FLOAT","build","dataIn","attrib","farray","deleteBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","STATIC_DRAW","getAttribLocation","enableVertexAttribArray","a","b","from","to","drawMode","drawArrays","Color","H","WGLDrawMode","WGLShader","WGLVertexBuffer","parse","doc","win","isNumber","isObject","merge","objectEach","asBar","asCircle","contexts","WGLRenderer","orthoMatrix","seriesPointCount","isStacked","xData","s","stacking","postRenderCallback","isInited","markerData","textureHandles","settings","pointSize","lineWidth","fillColor","useAlpha","usePreallocated","useGPUTranslations","debug","timeRendering","timeSeriesProcessing","timeSetup","timeBufferCopy","timeKDTree","showSkipSummary","getPixelRatio","devicePixelRatio","setOptions","vbuffer","allocateBufferForSingleSeries","COLOR_BUFFER_BIT","DEPTH_BUFFER_BIT","pushSeriesData","inst","isRange","pointArrayMap","sorted","rawData","xExtremes","getExtremes","xMin","xMax","yExtremes","yMin","yMax","yData","processedYData","zData","processedZData","useRaw","connectNulls","sdata","closestLeft","closestRight","chartDestroyed","index","drawAsBar","zoneAxis","zones","lastX","lastY","minVal","scolor","skipped","hadPoints","d","z","i","px","nx","low","nextInside","prevInside","pcolor","isXInside","isYInside","firstPoint","zoneColors","zoneDefColor","gapSize","vlen","boostData","gapUnit","closestPointRange","zone","zoneColor","rgba","value","seriesColor","pointAttribs","fill","closestPointRangePx","pushColor","colorData","vertice","checkTreshold","skipTranslation","closeSegment","segments","beginSegment","pushRect","w","h","node","levelDynamic","sort","point","swidth","pointAttr","plotY","isNaN","shapeArgs","styledMode","colorAttribs","stroke","pointOptions","slice","stackY","some","last","toPixels","hasMarkers","abs","step","console","log","pushSupplementPoint","atStart","concat","pushSeries","markerTo","time","markerFrom","marker","enabled","showMarkers","timeEnd","flush","setXAxis","transA","minPixelPadding","pointRange","horiz","logarithmic","reversed","setYAxis","setThreshold","has","translation","renderChart","chartWidth","chartHeight","viewport","isMS","si","shapeOptions","hasThreshold","yBottom","getThreshold","isRadial","radius","shapeTexture","symbol","circle","sindex","cbuffer","isReady","bindTexture","TEXTURE_2D","handle","getStyle","colorByPoint","colors","fillOpacity","setOpacity","get","boostBlending","blendFunc","SRC_ALPHA","ONE","blendEquation","FUNC_ADD","DST_COLOR","ZERO","FUNC_MIN","blendFuncSeparate","ONE_MINUS_SRC_ALPHA","Array","disableVertexAttribArray","renderer","forExport","setTimeout","setSize","init","noFlush","getContext","enable","BLEND","disable","DEPTH_TEST","depthFunc","LESS","createTexture","props","createElement","ctx","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","imageSmoothingEnabled","strokeStyle","fillStyle","activeTexture","TEXTURE0","texImage2D","RGBA","UNSIGNED_BYTE","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MAG_FILTER","LINEAR","TEXTURE_MIN_FILTER","e","beginPath","arc","PI","fillRect","moveTo","lineTo","deleteTexture","BoostChart","D","mainCanvas","getOptions","noop","extend","fireEvent","isArray","wrap","defined","composedMembers","allocateIfNotSeriesBoosting","boostEnabled","createAndAttachRenderer","targetGroup","seriesGroup","group","foSupported","SVGForeignObjectElement","renderTarget","image","addClass","add","attr","href","copy","resize","toDataURL","targetFo","targetCtx","element","appendChild","drawImage","css","pointerEvents","mixedBlendMode","opacity","clipRect","zIndex","clip","g","destroyGraphics","destroyElements","prop","seriesProp","zonesSeries","getZonesGraphs","zoneGraph","eachAsync","arr","finalFunc","chunkSize","noTimeout","proceed","requestAnimationFrame","hasExtremes","checkX","colorAxis","onSeriesDestroy","hoverPoints","filter","hoverPoint","onSeriesHide","renderIfNotSeriesBoosting","getPoint","boostPoint","PointClass","pointClass","category","categories","dist","distX","plotX","percentage","isInside","isPointInside","seriesRenderCanvas","pointTaken","sampling","enableMouseTracking","cropStart","requireSorting","compareX","findNearestPointBy","xDataFull","lastClientX","maxVal","minI","maxI","graph","plotGroup","addKDPoint","clientX","pushPoint","ceil","buildKDTree","wrapSeriesDrawPoints","call","wrapSeriesGetExtremes","arguments","wrapSeriesProcessData","dataToMeasure","getSeriesBoosting","forceCrop","getFirstValidPoint","enterBoost","bp","alteredByBoost","altered","own","Object","allowDG","directTouch","stickyTracking","finishedAnimating","labelBySeries","exitBoost","setting","wrapSeriesSearchPoint","result","SeriesClass","seriesTypes","seriesProto","renderCanvas","method","wrapSeriesFunctions","branch","letItPass","plotOptions","typePlotOptions","area","AreaSeries","areaspline","AreaSplineSeries","bubble","BubbleSeries","column","ColumnSeries","heatmap","HeatmapSeries","scatter","ScatterSeries","treemap","TreemapSeries","bubbleProto","SC","BoostSeries","Chart","BoostCanvas","destroyLoadingDiv","b64BlankPixel","areaCvsDrawPoint","lastPoint","bubbleCvsMarkerCircle","radii","columnCvsDrawPoint","rect","onChartCanvasToSVG","onChartClear","clearRect","seriesCanvasToSVG","seriesCvsLineTo","seriesGetContext","swapXY","c","style","activeBoostSettings","boostSettings","strokeBatch","cvsStrokeBatch","translatedThreshold","doFill","loadingOptions","loading","cvsDrawPoint","cvsLineTo","cvsMarker","cvsMarkerSquare","cvsMarkerCircle","labelStyle","backgroundColor","padding","borderRadius","clearTimeout","showLoading","wasNull","drawPoint","lineJoin","scroller","className","isNull","isNextInside","isPrevInside","NaN","round","loadingDiv","loadingShown","canvasToSVG","transition","parentNode","removeChild","loadingSpan","scatterCvsMarkerCircle","scatterCvsMarkerSquare","wrapHeatmapDrawPoints","left","areaProto","columnProto","heatmapProto","scatterProto","G","initCanvasBoost","Series"],"mappings":"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"}