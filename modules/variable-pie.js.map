{"version":3,"sources":["<anon>"],"sourcesContent":["/**\n * @license Highcharts JS v11.2.0 (2023-10-30)\n *\n * Variable Pie module for Highcharts\n *\n * (c) 2010-2021 Grzegorz Blachliński\n *\n * License: www.highcharts.com/license\n */\n(function (factory) {\n    if (typeof module === 'object' && module.exports) {\n        factory['default'] = factory;\n        module.exports = factory;\n    } else if (typeof define === 'function' && define.amd) {\n        define('highcharts/modules/variable-pie', ['highcharts'], function (Highcharts) {\n            factory(Highcharts);\n            factory.Highcharts = Highcharts;\n            return factory;\n        });\n    } else {\n        factory(typeof Highcharts !== 'undefined' ? Highcharts : undefined);\n    }\n}(function (Highcharts) {\n    'use strict';\n    var _modules = Highcharts ? Highcharts._modules : {};\n    function _registerModule(obj, path, args, fn) {\n        if (!obj.hasOwnProperty(path)) {\n            obj[path] = fn.apply(null, args);\n\n            if (typeof CustomEvent === 'function') {\n                window.dispatchEvent(new CustomEvent(\n                    'HighchartsModuleLoaded',\n                    { detail: { path: path, module: obj[path] } }\n                ));\n            }\n        }\n    }\n    _registerModule(_modules, 'Series/VariablePie/VariablePieSeriesDefaults.js', [], function () {\n        /* *\n         *\n         *  Variable Pie module for Highcharts\n         *\n         *  (c) 2010-2021 Grzegorz Blachliński\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        /* *\n         *\n         *  API Options\n         *\n         * */\n        /**\n         * A variable pie series is a two dimensional series type, where each point\n         * renders an Y and Z value.  Each point is drawn as a pie slice where the\n         * size (arc) of the slice relates to the Y value and the radius of pie\n         * slice relates to the Z value.\n         *\n         * @sample {highcharts} highcharts/demo/variable-radius-pie/\n         *         Variable-radius pie chart\n         *\n         * @extends      plotOptions.pie\n         * @excluding    dragDrop\n         * @since        6.0.0\n         * @product      highcharts\n         * @requires     modules/variable-pie.js\n         * @optionparent plotOptions.variablepie\n         */\n        const VariablePieSeriesDefaults = {\n            /**\n             * The minimum size of the points' radius related to chart's `plotArea`.\n             * If a number is set, it applies in pixels.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/min-max-point-size/\n             *         Example of minPointSize and maxPointSize\n             * @sample {highcharts} highcharts/variable-radius-pie/min-point-size-100/\n             *         minPointSize set to 100\n             *\n             * @type  {number|string}\n             * @since 6.0.0\n             */\n            minPointSize: '10%',\n            /**\n             * The maximum size of the points' radius related to chart's `plotArea`.\n             * If a number is set, it applies in pixels.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/min-max-point-size/\n             *         Example of minPointSize and maxPointSize\n             *\n             * @type  {number|string}\n             * @since 6.0.0\n             */\n            maxPointSize: '100%',\n            /**\n             * The minimum possible z value for the point's radius calculation. If\n             * the point's Z value is smaller than zMin, the slice will be drawn\n             * according to the zMin value.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-5/\n             *         zMin set to 5, smaller z values are treated as 5\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-zmax/\n             *         Series limited by both zMin and zMax\n             *\n             * @type  {number}\n             * @since 6.0.0\n             */\n            zMin: void 0,\n            /**\n             * The maximum possible z value for the point's radius calculation. If\n             * the point's Z value is bigger than zMax, the slice will be drawn\n             * according to the zMax value\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/zmin-zmax/\n             *         Series limited by both zMin and zMax\n             *\n             * @type  {number}\n             * @since 6.0.0\n             */\n            zMax: void 0,\n            /**\n             * Whether the pie slice's value should be represented by the area or\n             * the radius of the slice. Can be either `area` or `radius`. The\n             * default, `area`, corresponds best to the human perception of the size\n             * of each pie slice.\n             *\n             * @sample {highcharts} highcharts/variable-radius-pie/sizeby/\n             *         Difference between area and radius sizeBy\n             *\n             * @type  {Highcharts.VariablePieSizeByValue}\n             * @since 6.0.0\n             */\n            sizeBy: 'area',\n            tooltip: {\n                pointFormat: '<span style=\"color:{point.color}\">\\u25CF</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'\n            }\n        };\n        /**\n         * A `variablepie` series. If the [type](#series.variablepie.type) option is not\n         * specified, it is inherited from [chart.type](#chart.type).\n         *\n         * @extends   series,plotOptions.variablepie\n         * @excluding dataParser, dataURL, stack, xAxis, yAxis, dataSorting,\n         *            boostThreshold, boostBlending\n         * @product   highcharts\n         * @requires  modules/variable-pie.js\n         * @apioption series.variablepie\n         */\n        /**\n         * An array of data points for the series. For the `variablepie` series type,\n         * points can be given in the following ways:\n         *\n         * 1. An array of arrays with 2 values. In this case, the numerical values will\n         *    be interpreted as `y, z` options. Example:\n         *    ```js\n         *    data: [\n         *        [40, 75],\n         *        [50, 50],\n         *        [60, 40]\n         *    ]\n         *    ```\n         *\n         * 2. An array of objects with named values. The following snippet shows only a\n         *    few settings, see the complete options set below. If the total number of\n         *    data points exceeds the series'\n         *    [turboThreshold](#series.variablepie.turboThreshold), this option is not\n         *    available.\n         *    ```js\n         *    data: [{\n         *        y: 1,\n         *        z: 4,\n         *        name: \"Point2\",\n         *        color: \"#00FF00\"\n         *    }, {\n         *        y: 7,\n         *        z: 10,\n         *        name: \"Point1\",\n         *        color: \"#FF00FF\"\n         *    }]\n         *    ```\n         *\n         * @sample {highcharts} highcharts/series/data-array-of-arrays/\n         *         Arrays of numeric x and y\n         * @sample {highcharts} highcharts/series/data-array-of-arrays-datetime/\n         *         Arrays of datetime x and y\n         * @sample {highcharts} highcharts/series/data-array-of-name-value/\n         *         Arrays of point.name and y\n         * @sample {highcharts} highcharts/series/data-array-of-objects/\n         *         Config objects\n         *\n         * @type      {Array<Array<(number|string),number>|*>}\n         * @extends   series.pie.data\n         * @excluding marker, x\n         * @product   highcharts\n         * @apioption series.variablepie.data\n         */\n        ''; // keeps doclets above separate\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n\n        return VariablePieSeriesDefaults;\n    });\n    _registerModule(_modules, 'Series/VariablePie/VariablePieSeries.js', [_modules['Core/Series/SeriesRegistry.js'], _modules['Core/Utilities.js'], _modules['Series/VariablePie/VariablePieSeriesDefaults.js']], function (SeriesRegistry, U, VariablePieSeriesDefaults) {\n        /* *\n         *\n         *  Variable Pie module for Highcharts\n         *\n         *  (c) 2010-2021 Grzegorz Blachliński\n         *\n         *  License: www.highcharts.com/license\n         *\n         *  !!!!!!! SOURCE GETS TRANSPILED BY TYPESCRIPT. EDIT TS FILE ONLY. !!!!!!!\n         *\n         * */\n        const { pie: PieSeries } = SeriesRegistry.seriesTypes;\n        const { arrayMax, arrayMin, clamp, extend, fireEvent, merge, pick } = U;\n        /* *\n         *\n         *  Class\n         *\n         * */\n        /**\n         * The variablepie series type.\n         *\n         * @private\n         * @class\n         * @name Highcharts.seriesTypes.variablepie\n         *\n         * @augments Highcharts.Series\n         */\n        class VariablePieSeries extends PieSeries {\n            constructor() {\n                /* *\n                 *\n                 *  Static Properties\n                 *\n                 * */\n                super(...arguments);\n                /* *\n                 *\n                 *  Properties\n                 *\n                 * */\n                this.data = void 0;\n                this.options = void 0;\n                this.points = void 0;\n                this.radii = void 0;\n            }\n            /* *\n             *\n             *  Functions\n             *\n             * */\n            /**\n             * Before standard translate method for pie chart it is needed to calculate\n             * min/max radius of each pie slice based on its Z value.\n             * @private\n             */\n            calculateExtremes() {\n                const series = this, chart = series.chart, plotWidth = chart.plotWidth, plotHeight = chart.plotHeight, seriesOptions = series.options, slicingRoom = 2 * (seriesOptions.slicedOffset || 0), zData = series.zData, smallestSize = Math.min(plotWidth, plotHeight) - slicingRoom, \n                // Min and max size of pie slice:\n                extremes = {}, \n                // In pie charts size of a pie is changed to make space for\n                // dataLabels, then series.center is changing.\n                positions = series.center || series.getCenter();\n                let zMin, zMax;\n                for (const prop of ['minPointSize', 'maxPointSize']) {\n                    let length = seriesOptions[prop];\n                    const isPercent = /%$/.test(length);\n                    length = parseInt(length, 10);\n                    extremes[prop] = isPercent ?\n                        smallestSize * length / 100 :\n                        length * 2; // Because it should be radius, not diameter.\n                }\n                series.minPxSize = positions[3] + extremes.minPointSize;\n                series.maxPxSize = clamp(positions[2], positions[3] + extremes.minPointSize, extremes.maxPointSize);\n                if (zData.length) {\n                    zMin = pick(seriesOptions.zMin, arrayMin(zData.filter(series.zValEval)));\n                    zMax = pick(seriesOptions.zMax, arrayMax(zData.filter(series.zValEval)));\n                    this.getRadii(zMin, zMax, series.minPxSize, series.maxPxSize);\n                }\n            }\n            /**\n             * Finding radius of series points based on their Z value and min/max Z\n             * value for all series.\n             *\n             * @private\n             * @function Highcharts.Series#getRadii\n             *\n             * @param {number} zMin\n             * Min threshold for Z value. If point's Z value is smaller that zMin, point\n             * will have the smallest possible radius.\n             *\n             * @param {number} zMax\n             * Max threshold for Z value. If point's Z value is bigger that zMax, point\n             * will have the biggest possible radius.\n             *\n             * @param {number} minSize\n             * Minimal pixel size possible for radius.\n             *\n             * @param {numbner} maxSize\n             * Minimal pixel size possible for radius.\n             */\n            getRadii(zMin, zMax, minSize, maxSize) {\n                const zData = this.zData, radii = [], options = this.options, sizeByArea = options.sizeBy !== 'radius', zRange = zMax - zMin;\n                let pos, value, radius;\n                // Calculate radius for all pie slice's based on their Z values\n                for (let i = 0; i < zData.length; i++) {\n                    // if zData[i] is null/undefined/string we need to take zMin for\n                    // smallest radius.\n                    value = this.zValEval(zData[i]) ? zData[i] : zMin;\n                    if (value <= zMin) {\n                        radius = minSize / 2;\n                    }\n                    else if (value >= zMax) {\n                        radius = maxSize / 2;\n                    }\n                    else {\n                        // Relative size, a number between 0 and 1\n                        pos = zRange > 0 ? (value - zMin) / zRange : 0.5;\n                        if (sizeByArea) {\n                            pos = Math.sqrt(pos);\n                        }\n                        radius = Math.ceil(minSize + pos * (maxSize - minSize)) / 2;\n                    }\n                    radii.push(radius);\n                }\n                this.radii = radii;\n            }\n            /**\n             * It is needed to null series.center on chart redraw. Probably good idea\n             * will be to add this option in directly in pie series.\n             * @private\n             */\n            redraw() {\n                this.center = null;\n                super.redraw();\n            }\n            /** @private */\n            getDataLabelPosition(point, distance) {\n                const { center, options } = this, angle = point.angle || 0, r = this.radii[point.index], x = center[0] + Math.cos(angle) * r, y = center[1] + Math.sin(angle) * r, connectorOffset = (options.slicedOffset || 0) +\n                    (options.borderWidth || 0), \n                // Set the anchor point for data labels. Use point.labelDistance\n                // instead of labelDistance // #1174\n                // finalConnectorOffset - not override connectorOffset value.\n                finalConnectorOffset = Math.min(connectorOffset, distance / 5); // #1678\n                return {\n                    distance,\n                    natural: {\n                        // Initial position of the data label - it's utilized for\n                        // finding the final position for the label\n                        x: x + Math.cos(angle) * distance,\n                        y: y + Math.sin(angle) * distance\n                    },\n                    computed: {\n                    // Used for generating connector path - initialized later in\n                    // drawDataLabels function x: undefined, y: undefined\n                    },\n                    // Left - pie on the left side of the data label\n                    // Right - pie on the right side of the data label\n                    alignment: point.half ? 'right' : 'left',\n                    connectorPosition: {\n                        breakAt: {\n                            x: x + Math.cos(angle) * finalConnectorOffset,\n                            y: y + Math.sin(angle) * finalConnectorOffset\n                        },\n                        touchingSliceAt: {\n                            x,\n                            y\n                        }\n                    }\n                };\n            }\n            /**\n             * Extend translate by updating radius for each pie slice instead of using\n             * one global radius.\n             * @private\n             */\n            translate(positions) {\n                this.generatePoints();\n                const series = this, precision = 1000, // issue #172\n                options = series.options, slicedOffset = options.slicedOffset, startAngle = options.startAngle || 0, startAngleRad = Math.PI / 180 * (startAngle - 90), endAngleRad = Math.PI / 180 * (pick(options.endAngle, startAngle + 360) - 90), circ = endAngleRad - startAngleRad, // 2 * Math.PI,\n                points = series.points, ignoreHiddenPoint = options.ignoreHiddenPoint;\n                let cumulative = 0, start, end, angle, \n                // the x component of the radius vector for a given point\n                radiusX, radiusY, point, pointRadii;\n                series.startAngleRad = startAngleRad;\n                series.endAngleRad = endAngleRad;\n                // Use calculateExtremes to get series.radii array.\n                series.calculateExtremes();\n                // Get positions - either an integer or a percentage string must be\n                // given. If positions are passed as a parameter, we're in a\n                // recursive loop for adjusting space for data labels.\n                if (!positions) {\n                    series.center = positions = series.getCenter();\n                }\n                // Calculate the geometry for each point\n                for (let i = 0; i < points.length; i++) {\n                    point = points[i];\n                    pointRadii = series.radii[i];\n                    // Set start and end angle\n                    start = startAngleRad + (cumulative * circ);\n                    if (!ignoreHiddenPoint || point.visible) {\n                        cumulative += point.percentage / 100;\n                    }\n                    end = startAngleRad + (cumulative * circ);\n                    // Set the shape\n                    point.shapeType = 'arc';\n                    point.shapeArgs = {\n                        x: positions[0],\n                        y: positions[1],\n                        r: pointRadii,\n                        innerR: positions[3] / 2,\n                        start: Math.round(start * precision) / precision,\n                        end: Math.round(end * precision) / precision\n                    };\n                    // The angle must stay within -90 and 270 (#2645)\n                    angle = (end + start) / 2;\n                    if (angle > 1.5 * Math.PI) {\n                        angle -= 2 * Math.PI;\n                    }\n                    else if (angle < -Math.PI / 2) {\n                        angle += 2 * Math.PI;\n                    }\n                    // Center for the sliced out slice\n                    point.slicedTranslation = {\n                        translateX: Math.round(Math.cos(angle) * slicedOffset),\n                        translateY: Math.round(Math.sin(angle) * slicedOffset)\n                    };\n                    // Set the anchor point for tooltips\n                    radiusX = Math.cos(angle) * positions[2] / 2;\n                    radiusY = Math.sin(angle) * positions[2] / 2;\n                    point.tooltipPos = [\n                        positions[0] + radiusX * 0.7,\n                        positions[1] + radiusY * 0.7\n                    ];\n                    point.half = angle < -Math.PI / 2 || angle > Math.PI / 2 ?\n                        1 :\n                        0;\n                    point.angle = angle;\n                }\n                fireEvent(series, 'afterTranslate');\n            }\n            /**\n             * For arrayMin and arrayMax calculations array shouldn't have\n             * null/undefined/string values. In this case it is needed to check if\n             * points Z value is a Number.\n             * @private\n             */\n            zValEval(zVal) {\n                if (typeof zVal === 'number' && !isNaN(zVal)) {\n                    return true;\n                }\n                return null;\n            }\n        }\n        VariablePieSeries.defaultOptions = merge(PieSeries.defaultOptions, VariablePieSeriesDefaults);\n        extend(VariablePieSeries.prototype, {\n            pointArrayMap: ['y', 'z'],\n            parallelArrays: ['x', 'y', 'z']\n        });\n        SeriesRegistry.registerSeriesType('variablepie', VariablePieSeries);\n        /* *\n         *\n         *  Default Export\n         *\n         * */\n        /* *\n         *\n         *  API Declarations\n         *\n         * */\n        /**\n         * @typedef {\"area\"|\"radius\"} Highcharts.VariablePieSizeByValue\n         */\n        ''; // adds doclets above to transpiled file\n\n        return VariablePieSeries;\n    });\n    _registerModule(_modules, 'masters/modules/variable-pie.src.js', [], function () {\n\n\n    });\n}));"],"names":["factory","module","exports","define","amd","Highcharts","undefined","_modules","_registerModule","obj","path","args","fn","hasOwnProperty","apply","CustomEvent","window","dispatchEvent","detail","minPointSize","maxPointSize","zMin","zMax","sizeBy","tooltip","pointFormat","SeriesRegistry","U","VariablePieSeriesDefaults","pie","PieSeries","seriesTypes","arrayMax","arrayMin","clamp","extend","fireEvent","merge","pick","VariablePieSeries","constructor","arguments","data","options","points","radii","calculateExtremes","chart","series","plotWidth","plotHeight","seriesOptions","slicingRoom","slicedOffset","zData","smallestSize","Math","min","extremes","positions","center","getCenter","prop","length","isPercent","test","parseInt","minPxSize","maxPxSize","filter","zValEval","getRadii","minSize","maxSize","pos","value","radius","sizeByArea","zRange","i","sqrt","ceil","push","redraw","getDataLabelPosition","point","distance","angle","r","index","x","cos","y","sin","connectorOffset","borderWidth","finalConnectorOffset","natural","computed","alignment","half","connectorPosition","breakAt","touchingSliceAt","translate","generatePoints","startAngle","startAngleRad","PI","endAngleRad","endAngle","circ","ignoreHiddenPoint","cumulative","start","end","radiusX","radiusY","pointRadii","visible","percentage","shapeType","shapeArgs","innerR","round","slicedTranslation","translateX","translateY","tooltipPos","zVal","isNaN","defaultOptions","prototype","pointArrayMap","parallelArrays","registerSeriesType"],"mappings":"AAAA;;;;;;;;CAQC,GACA,SAAUA,CAAO,EACV,AAAkB,UAAlB,OAAOC,QAAuBA,OAAOC,OAAO,EAC5CF,EAAQ,OAAU,CAAGA,EACrBC,OAAOC,OAAO,CAAGF,GACV,AAAkB,YAAlB,OAAOG,QAAyBA,OAAOC,GAAG,CACjDD,OAAO,kCAAmC,CAAC,aAAa,CAAE,SAAUE,CAAU,EAG1E,OAFAL,EAAQK,GACRL,EAAQK,UAAU,CAAGA,EACdL,CACX,GAEAA,EAAQ,AAAsB,aAAtB,OAAOK,WAA6BA,WAAaC,KAAAA,EAEjE,EAAE,SAAUD,CAAU,EAClB,aACA,IAAIE,EAAWF,EAAaA,EAAWE,QAAQ,CAAG,CAAC,EACnD,SAASC,EAAgBC,CAAG,CAAEC,CAAI,CAAEC,CAAI,CAAEC,CAAE,EACnCH,EAAII,cAAc,CAACH,KACpBD,CAAG,CAACC,EAAK,CAAGE,EAAGE,KAAK,CAAC,KAAMH,GAEA,YAAvB,OAAOI,aACPC,OAAOC,aAAa,CAAC,IAAIF,YACrB,yBACA,CAAEG,OAAQ,CAAER,KAAMA,EAAMT,OAAQQ,CAAG,CAACC,EAAK,AAAC,CAAE,IAI5D,CACAF,EAAgBD,EAAU,kDAAmD,EAAE,CAAE,WAuK7E,MAtIkC,CAa9BY,aAAc,MAWdC,aAAc,OAcdC,KAAM,KAAK,EAYXC,KAAM,KAAK,EAaXC,OAAQ,OACRC,QAAS,CACLC,YAAa,wGACjB,CACJ,CAoEJ,GACAjB,EAAgBD,EAAU,0CAA2C,CAACA,CAAQ,CAAC,gCAAgC,CAAEA,CAAQ,CAAC,oBAAoB,CAAEA,CAAQ,CAAC,kDAAkD,CAAC,CAAE,SAAUmB,CAAc,CAAEC,CAAC,CAAEC,CAAyB,EAYhQ,GAAM,CAAEC,IAAKC,CAAS,CAAE,CAAGJ,EAAeK,WAAW,CAC/C,CAAEC,SAAAA,CAAQ,CAAEC,SAAAA,CAAQ,CAAEC,MAAAA,CAAK,CAAEC,OAAAA,CAAM,CAAEC,UAAAA,CAAS,CAAEC,MAAAA,CAAK,CAAEC,KAAAA,CAAI,CAAE,CAAGX,CAetE,OAAMY,UAA0BT,EAC5BU,aAAc,CAMV,KAAK,IAAIC,WAMT,IAAI,CAACC,IAAI,CAAG,KAAK,EACjB,IAAI,CAACC,OAAO,CAAG,KAAK,EACpB,IAAI,CAACC,MAAM,CAAG,KAAK,EACnB,IAAI,CAACC,KAAK,CAAG,KAAK,CACtB,CAWAC,mBAAoB,KAOZzB,EAAMC,EANV,IAAqByB,EAAQC,AAAd,IAAI,CAAiBD,KAAK,CAAEE,EAAYF,EAAME,SAAS,CAAEC,EAAaH,EAAMG,UAAU,CAAEC,EAAgBH,AAAxG,IAAI,CAA2GL,OAAO,CAAES,EAAc,EAAKD,CAAAA,EAAcE,YAAY,EAAI,CAAA,EAAIC,EAAQN,AAArL,IAAI,CAAwLM,KAAK,CAAEC,EAAeC,KAAKC,GAAG,CAACR,EAAWC,GAAcE,EAEnQM,EAAW,CAAC,EAGZC,EAAYX,AALG,IAAI,CAKAY,MAAM,EAAIZ,AALd,IAAI,CAKiBa,SAAS,GAE7C,IAAK,IAAMC,IAAQ,CAAC,eAAgB,eAAe,CAAE,CACjD,IAAIC,EAASZ,CAAa,CAACW,EAAK,CAC1BE,EAAY,KAAKC,IAAI,CAACF,GAC5BA,EAASG,SAASH,EAAQ,IAC1BL,CAAQ,CAACI,EAAK,CAAGE,EACbT,EAAeQ,EAAS,IACxBA,AAAS,EAATA,CACR,CACAf,AAfe,IAAI,CAeZmB,SAAS,CAAGR,CAAS,CAAC,EAAE,CAAGD,EAASvC,YAAY,CACvD6B,AAhBe,IAAI,CAgBZoB,SAAS,CAAGlC,EAAMyB,CAAS,CAAC,EAAE,CAAEA,CAAS,CAAC,EAAE,CAAGD,EAASvC,YAAY,CAAEuC,EAAStC,YAAY,EAC9FkC,EAAMS,MAAM,GACZ1C,EAAOiB,EAAKa,EAAc9B,IAAI,CAAEY,EAASqB,EAAMe,MAAM,CAACrB,AAlB3C,IAAI,CAkB8CsB,QAAQ,IACrEhD,EAAOgB,EAAKa,EAAc7B,IAAI,CAAEU,EAASsB,EAAMe,MAAM,CAACrB,AAnB3C,IAAI,CAmB8CsB,QAAQ,IACrE,IAAI,CAACC,QAAQ,CAAClD,EAAMC,EAAM0B,AApBf,IAAI,CAoBkBmB,SAAS,CAAEnB,AApBjC,IAAI,CAoBoCoB,SAAS,EAEpE,CAsBAG,SAASlD,CAAI,CAAEC,CAAI,CAAEkD,CAAO,CAAEC,CAAO,CAAE,KAE/BC,EAAKC,EAAOC,EADhB,IAAMtB,EAAQ,IAAI,CAACA,KAAK,CAAET,EAAQ,EAAE,CAAEF,EAAU,IAAI,CAACA,OAAO,CAAEkC,EAAalC,AAAmB,WAAnBA,EAAQpB,MAAM,CAAeuD,EAASxD,EAAOD,EAGxH,IAAK,IAAI0D,EAAI,EAAGA,EAAIzB,EAAMS,MAAM,CAAEgB,IAI1BJ,AADJA,CAAAA,EAAQ,IAAI,CAACL,QAAQ,CAAChB,CAAK,CAACyB,EAAE,EAAIzB,CAAK,CAACyB,EAAE,CAAG1D,CAAG,GACnCA,EACTuD,EAASJ,EAAU,EAEdG,GAASrD,EACdsD,EAASH,EAAU,GAInBC,EAAMI,EAAS,EAAI,AAACH,CAAAA,EAAQtD,CAAG,EAAKyD,EAAS,GACzCD,GACAH,CAAAA,EAAMlB,KAAKwB,IAAI,CAACN,EAAG,EAEvBE,EAASpB,KAAKyB,IAAI,CAACT,EAAUE,EAAOD,CAAAA,EAAUD,CAAM,GAAM,GAE9D3B,EAAMqC,IAAI,CAACN,EAEf,CAAA,IAAI,CAAC/B,KAAK,CAAGA,CACjB,CAMAsC,QAAS,CACL,IAAI,CAACvB,MAAM,CAAG,KACd,KAAK,CAACuB,QACV,CAEAC,qBAAqBC,CAAK,CAAEC,CAAQ,CAAE,CAClC,GAAM,CAAE1B,OAAAA,CAAM,CAAEjB,QAAAA,CAAO,CAAE,CAAG,IAAI,CAAE4C,EAAQF,EAAME,KAAK,EAAI,EAAGC,EAAI,IAAI,CAAC3C,KAAK,CAACwC,EAAMI,KAAK,CAAC,CAAEC,EAAI9B,CAAM,CAAC,EAAE,CAAGJ,KAAKmC,GAAG,CAACJ,GAASC,EAAGI,EAAIhC,CAAM,CAAC,EAAE,CAAGJ,KAAKqC,GAAG,CAACN,GAASC,EAAGM,EAAkB,AAACnD,CAAAA,EAAQU,YAAY,EAAI,CAAA,EACzMV,CAAAA,EAAQoD,WAAW,EAAI,CAAA,EAI5BC,EAAuBxC,KAAKC,GAAG,CAACqC,EAAiBR,EAAW,GAC5D,MAAO,CACHA,SAAAA,EACAW,QAAS,CAGLP,EAAGA,EAAIlC,KAAKmC,GAAG,CAACJ,GAASD,EACzBM,EAAGA,EAAIpC,KAAKqC,GAAG,CAACN,GAASD,CAC7B,EACAY,SAAU,CAGV,EAGAC,UAAWd,EAAMe,IAAI,CAAG,QAAU,OAClCC,kBAAmB,CACfC,QAAS,CACLZ,EAAGA,EAAIlC,KAAKmC,GAAG,CAACJ,GAASS,EACzBJ,EAAGA,EAAIpC,KAAKqC,GAAG,CAACN,GAASS,CAC7B,EACAO,gBAAiB,CACbb,EAAAA,EACAE,EAAAA,CACJ,CACJ,CACJ,CACJ,CAMAY,UAAU7C,CAAS,CAAE,CACjB,IAAI,CAAC8C,cAAc,GACnB,IACA9D,EAAUK,AADK,IAAI,CACFL,OAAO,CAAEU,EAAeV,EAAQU,YAAY,CAAEqD,EAAa/D,EAAQ+D,UAAU,EAAI,EAAGC,EAAgBnD,KAAKoD,EAAE,CAAG,IAAOF,CAAAA,EAAa,EAAC,EAAIG,EAAcrD,KAAKoD,EAAE,CAAG,IAAOtE,CAAAA,EAAKK,EAAQmE,QAAQ,CAAEJ,EAAa,KAAO,EAAC,EAAIK,EAAOF,EAAcF,EAC5P/D,EAASI,AAFM,IAAI,CAEHJ,MAAM,CAAEoE,EAAoBrE,EAAQqE,iBAAiB,CACjEC,EAAa,EAAGC,EAAOC,EAAK5B,EAEhC6B,EAASC,EAAShC,EAAOiC,CACzBtE,CANe,IAAI,CAMZ2D,aAAa,CAAGA,EACvB3D,AAPe,IAAI,CAOZ6D,WAAW,CAAGA,EAErB7D,AATe,IAAI,CASZF,iBAAiB,GAInBa,GACDX,CAAAA,AAdW,IAAI,CAcRY,MAAM,CAAGD,EAAYX,AAdjB,IAAI,CAcoBa,SAAS,EAAC,EAGjD,IAAK,IAAIkB,EAAI,EAAGA,EAAInC,EAAOmB,MAAM,CAAEgB,IAC/BM,EAAQzC,CAAM,CAACmC,EAAE,CACjBuC,EAAatE,AAnBF,IAAI,CAmBKH,KAAK,CAACkC,EAAE,CAE5BmC,EAAQP,EAAiBM,EAAaF,EAClC,CAAA,CAACC,GAAqB3B,EAAMkC,OAAO,AAAD,GAClCN,CAAAA,GAAc5B,EAAMmC,UAAU,CAAG,GAAE,EAEvCL,EAAMR,EAAiBM,EAAaF,EAEpC1B,EAAMoC,SAAS,CAAG,MAClBpC,EAAMqC,SAAS,CAAG,CACdhC,EAAG/B,CAAS,CAAC,EAAE,CACfiC,EAAGjC,CAAS,CAAC,EAAE,CACf6B,EAAG8B,EACHK,OAAQhE,CAAS,CAAC,EAAE,CAAG,EACvBuD,MAAO1D,KAAKoE,KAAK,CAACV,AAjCO,IAiCPA,GAjCO,IAkCzBC,IAAK3D,KAAKoE,KAAK,CAACT,AAlCS,IAkCTA,GAlCS,GAmC7B,EAGI5B,AADJA,CAAAA,EAAQ,AAAC4B,CAAAA,EAAMD,CAAI,EAAK,CAAA,EACZ,IAAM1D,KAAKoD,EAAE,CACrBrB,GAAS,EAAI/B,KAAKoD,EAAE,CAEfrB,EAAQ,CAAC/B,KAAKoD,EAAE,CAAG,GACxBrB,CAAAA,GAAS,EAAI/B,KAAKoD,EAAE,AAAD,EAGvBvB,EAAMwC,iBAAiB,CAAG,CACtBC,WAAYtE,KAAKoE,KAAK,CAACpE,KAAKmC,GAAG,CAACJ,GAASlC,GACzC0E,WAAYvE,KAAKoE,KAAK,CAACpE,KAAKqC,GAAG,CAACN,GAASlC,EAC7C,EAEA+D,EAAU5D,KAAKmC,GAAG,CAACJ,GAAS5B,CAAS,CAAC,EAAE,CAAG,EAC3C0D,EAAU7D,KAAKqC,GAAG,CAACN,GAAS5B,CAAS,CAAC,EAAE,CAAG,EAC3C0B,EAAM2C,UAAU,CAAG,CACfrE,CAAS,CAAC,EAAE,CAAGyD,AAAU,GAAVA,EACfzD,CAAS,CAAC,EAAE,CAAG0D,AAAU,GAAVA,EAClB,CACDhC,EAAMe,IAAI,CAAGb,EAAQ,CAAC/B,KAAKoD,EAAE,CAAG,GAAKrB,EAAQ/B,KAAKoD,EAAE,CAAG,EACnD,EACA,EACJvB,EAAME,KAAK,CAAGA,EAElBnD,EA7De,IAAI,CA6DD,iBACtB,CAOAkC,SAAS2D,CAAI,CAAE,OACX,CAAI,CAAA,AAAgB,UAAhB,OAAOA,GAAsBC,MAAMD,EAAI,GAGpC,IACX,CACJ,CAsBA,OArBA1F,EAAkB4F,cAAc,CAAG9F,EAAMP,EAAUqG,cAAc,CAAEvG,GACnEO,EAAOI,EAAkB6F,SAAS,CAAE,CAChCC,cAAe,CAAC,IAAK,IAAI,CACzBC,eAAgB,CAAC,IAAK,IAAK,IAAI,AACnC,GACA5G,EAAe6G,kBAAkB,CAAC,cAAehG,GAgB1CA,CACX,GACA/B,EAAgBD,EAAU,sCAAuC,EAAE,CAAE,WAGrE,EACJ"}