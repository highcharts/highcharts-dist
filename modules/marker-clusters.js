!/**
 * Highcharts JS v12.5.0 (2026-01-12)
 * @module highcharts/modules/marker-clusters
 * @requires highcharts
 *
 * Marker clusters module for Highcharts
 *
 * (c) 2010-2026 Highsoft AS
 * Author: Wojciech Chmiel
 *
 * A commercial license may be required depending on use.
 * See www.highcharts.com/license
 */function(t,e){"object"==typeof exports&&"object"==typeof module?module.exports=e(t._Highcharts):"function"==typeof define&&define.amd?define("highcharts/modules/marker-clusters",["highcharts/highcharts"],function(t){return e(t)}):"object"==typeof exports?exports["highcharts/modules/marker-clusters"]=e(t._Highcharts):t.Highcharts=e(t.Highcharts)}("u"<typeof window?this:window,t=>(()=>{"use strict";let e;var i,s,r={944:e=>{e.exports=t}},o={};function a(t){var e=o[t];if(void 0!==e)return e.exports;var i=o[t]={exports:{}};return r[t](i,i.exports,a),i.exports}a.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},a.d=(t,e)=>{for(var i in e)a.o(e,i)&&!a.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);var n={};a.d(n,{default:()=>tk});var l=a(944),u=a.n(l);let p={cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}};(i=s||(s={})).setLength=function(t,e,i){return Array.isArray(t)?(t.length=e,t):t[i?"subarray":"slice"](0,e)},i.splice=function(t,e,i,s,r=[]){if(Array.isArray(t))return Array.isArray(r)||(r=Array.from(r)),{removed:t.splice(e,i,...r),array:t};let o=Object.getPrototypeOf(t).constructor,a=t[s?"subarray":"slice"](e,e+i),n=new o(t.length-i+r.length);return n.set(t.subarray(0,e),0),n.set(r,e),n.set(t.subarray(e+i),e+r.length),{removed:a,array:n}},i.convertToNumber=function(t,e){switch(typeof t){case"boolean":return+!!t;case"number":return isNaN(t)&&!e?null:t;default:return isNaN(t=parseFloat(`${t??""}`))&&!e?null:t}};let{setLength:h,splice:d}=s,{fireEvent:c,objectEach:m,uniqueKey:f}=u(),g=class{constructor(t={}){this.autoId=!t.id,this.columns={},this.id=t.id||f(),this.rowCount=0,this.versionTag=f();let e=0;m(t.columns||{},(t,i)=>{this.columns[i]=t.slice(),e=Math.max(e,t.length)}),this.applyRowCount(e)}applyRowCount(t){this.rowCount=t,m(this.columns,(e,i)=>{e.length!==t&&(this.columns[i]=h(e,t))})}deleteRows(t,e=1){if(e>0&&t<this.rowCount){let i=0;m(this.columns,(s,r)=>{this.columns[r]=d(s,t,e).array,i=s.length}),this.rowCount=i}c(this,"afterDeleteRows",{rowIndex:t,rowCount:e}),this.versionTag=f()}getColumn(t,e){return this.columns[t]}getColumns(t,e){return(t||Object.keys(this.columns)).reduce((t,e)=>(t[e]=this.columns[e],t),{})}getRow(t,e){return(e||Object.keys(this.columns)).map(e=>this.columns[e]?.[t])}setColumn(t,e=[],i=0,s){this.setColumns({[t]:e},i,s)}setColumns(t,e,i){let s=this.rowCount;m(t,(t,e)=>{this.columns[e]=t.slice(),s=t.length}),this.applyRowCount(s),i?.silent||(c(this,"afterSetColumns"),this.versionTag=f())}setRow(t,e=this.rowCount,i,s){let{columns:r}=this,o=i?this.rowCount+1:e+1,a=Object.keys(t);if(s?.addColumns!==!1)for(let t=0,e=a.length;t<e;t++){let e=a[t];r[e]||(r[e]=[])}m(r,(a,n)=>{a||s?.addColumns===!1||(a=Array(o)),a&&(i?a=d(a,e,0,!0,[t[n]??null]).array:a[e]=t[n]??null,r[n]=a)}),o>this.rowCount&&this.applyRowCount(o),s?.silent||(c(this,"afterSetRows"),this.versionTag=f())}getModified(){return this.modified||this}},{animObject:x}=u(),{cluster:y}=p,{addEvent:C,defined:k,error:I,isArray:b,isFunction:M,isObject:S,isNumber:w,merge:A,objectEach:P,relativeLength:X,syncTimeout:Y}=u(),L={grid:function(t,e,i,s){let r,o,a,n,l,u={},p=this.getGridOffset(),h=this.getScaledGridSize(s);for(l=0;l<t.length;l++){let s=te(this,{x:t[l],y:e[l]});r=s.x-p.plotLeft,o=s.y-p.plotTop,a=Math.floor(r/h),u[n=Math.floor(o/h)+":"+a]??(u[n]=[]),u[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return u},kmeans:function(t,e,i,s){let r=[],o=[],a={},n=s.processedDistance||y.layoutAlgorithm.distance,l=s.iterations,u=0,p=!0,h=0,d=0,c,m=[];s.processedGridSize=s.processedDistance;let f=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,s):{};for(let t in f)f[t].length>1&&(c=V(f[t]),r.push({posX:c.x,posY:c.y,oldX:0,oldY:0,startPointsLen:f[t].length,points:[]}));for(;p;){for(let t of r)t.points.length=0;o.length=0;for(let s=0;s<t.length;s++)h=t[s],d=e[s],(m=this.getClusterDistancesFromPoint(r,h,d)).length&&m[0].distance<n?r[m[0].clusterIndex].points.push({x:h,y:d,dataIndex:i[s]}):o.push({x:h,y:d,dataIndex:i[s]});for(let t=0;t<r.length;t++)1===r[t].points.length&&(m=this.getClusterDistancesFromPoint(r,r[t].points[0].x,r[t].points[0].y))[1].distance<n&&(r[m[1].clusterIndex].points.push(r[t].points[0]),r[m[0].clusterIndex].points.length=0);p=!1;for(let t=0;t<r.length;t++)c=V(r[t].points),r[t].oldX=r[t].posX,r[t].oldY=r[t].posY,r[t].posX=c.x,r[t].posY=c.y,(r[t].posX>r[t].oldX+1||r[t].posX<r[t].oldX-1||r[t].posY>r[t].oldY+1||r[t].posY<r[t].oldY-1)&&(p=!0);l&&(p=u<l-1),u++}for(let t=0,e=r.length;t<e;++t)a["cluster"+t]=r[t].points;for(let t=0,e=o.length;t<e;++t)a["noise"+t]=[o[t]];return a},optimizedKmeans:function(t,e,i,s){let r=s.processedDistance||y.layoutAlgorithm.gridSize,o=this.getRealExtremes(),a=(this.options.cluster||{}).marker,n,l={},u,p;if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<o.maxX||this.initMinX&&this.initMinX>o.minX||this.initMaxY&&this.initMaxY<o.maxY||this.initMinY&&this.initMinY>o.minY)this.initMaxX=o.maxX,this.initMinX=o.minX,this.initMaxY=o.maxY,this.initMinY=o.minY,l=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(let t of(this.baseClusters??(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(let e of(t.pointsOutside=[],t.pointsInside=[],t.data)){let i=te(this,e),s=te(this,t);n=Math.sqrt(Math.pow(i.x-s.x,2)+Math.pow(i.y-s.y,2)),u=r-(p=t.clusterZone?.marker?.radius?t.clusterZone.marker.radius:a?.radius?a.radius:y.marker.radius)>=0?r-p:p,n>p+u&&k(t.pointsOutside)?t.pointsOutside.push(e):k(t.pointsInside)&&t.pointsInside.push(e)}t.pointsInside.length&&(l[t.id]=t.pointsInside);let e=0;for(let i of t.pointsOutside)l[t.id+"_noise"+e++]=[i]}for(let t of this.baseClusters.noise)l[t.id]=t.data}return l}},z,O=[],D=0;function v(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function T(t,e,i,s){for(let r of(R(t,s,i,!0,!0),e))r.point?.destroy?.()}function R(t,e,i,s,r){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),v(t.point.graphic,e,i)),r&&t.point.dataLabel&&(t.point.dataLabel.show(),v(t.point.dataLabel,e,i)))}function V(t){let e=t.length,i=0,s=0;for(let r=0;r<e;r++)i+=t[r].x,s+=t[r].y;return{x:i/e,y:s/e}}function j(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function E(){return Math.random().toString(36).substring(2,7)+"-"+D++}function G(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function F(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){let e=t.point||t.target,i=e.series,{xAxis:s,yAxis:r,chart:o}=i,{inverted:a,mapView:n,pointer:l}=o;if(i.options.cluster?.drillToCluster&&e.clusteredData){let t=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),i=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),u=t[0],p=t[t.length-1],h=i[0],d=i[i.length-1],c=Math.abs((p-u)*.1),m=Math.abs((d-h)*.1),f=Math.min(u,p)-c,g=Math.max(u,p)+c,x=Math.min(h,d)-m,y=Math.max(h,d)+m;if(n)n.fitToBounds({x1:f,x2:g,y1:x,y2:y});else if(s&&r){let t=s.toPixels(f),e=s.toPixels(g),i=r.toPixels(x),n=r.toPixels(y);a&&([t,e,i,n]=[i,n,t,e]),t>e&&([t,e]=[e,t]),i>n&&([i,n]=[n,i]),l&&(l.zoomX=!0,l.zoomY=!0),o.transform({from:{x:t,y:i,width:e-t,height:n-i}})}}})}function H(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:r?r.toValue(e.y):0}}function N(t){let e=this.chart,i=e.mapView,s=x(this.options.cluster?.animation),r=s.duration||500,o=this.markerClusterInfo?.pointsState,a=o?.newState,n=o?.oldState,l=[],u,p,h,d=0,c=0,m=0,f=!1,g=!1;if(n&&a){let o=te(this,p=a[t.stateId]);c=o.x-(i?0:e.plotLeft),m=o.y-(i?0:e.plotTop),1===p.parentsId.length?(u=n[a?.[t.stateId].parentsId[0]],p.point?.graphic&&u.point?.plotX&&u.point.plotY&&(u.point.plotX!==p.point.plotX||u.point.plotY!==p.point.plotY)&&(h=p.point.graphic.getBBox(),d=p.point.graphic?.isImg?0:h.width/2,p.point.graphic.attr({x:u.point.plotX-d,y:u.point.plotY-d}),p.point.graphic.animate({x:c-(p.point.graphic.radius||0),y:m-(p.point.graphic.radius||0)},s,function(){g=!0,u.point?.destroy?.()}),p.point.dataLabel?.alignAttr&&u.point.dataLabel?.alignAttr&&(p.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),p.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y},s)))):0===p.parentsId.length?(G(p,!0,!0),Y(function(){R(p,.1,s,!0,!0)},r/2)):(G(p,!0,!0),p.parentsId.forEach(function(t){n?.[t]&&(u=n[t],l.push(u),u.point?.graphic&&(f=!0,u.point.graphic.show(),u.point.graphic.animate({x:c-(u.point.graphic.radius||0),y:m-(u.point.graphic.radius||0),opacity:.4},s,function(){g=!0,T(p,l,s,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&p.point?.dataLabel?.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y,opacity:.4},s))))}),Y(function(){g||T(p,l,s,.85)},r),f||Y(function(){T(p,l,s,.1)},r/2))}}function W(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function Z(){let t,e,i,s,r,o,a,n,l,u,p,h,d,c,m,f=this,{chart:x}=f,I=x.mapView,b=f.getColumn("x"),S=f.getColumn("y"),A=f.options.cluster,P=f.getRealExtremes(),Y=[],L=[],O=[];if(I&&f.is("mappoint")&&b&&S&&f.options.data?.forEach((t,e)=>{let i=f.projectPoint(t);i&&(b[e]=i.x,S[e]=i.y)}),A?.enabled&&b?.length&&S?.length&&!x.polar){p=A.layoutAlgorithm.type,(c=A.layoutAlgorithm).processedGridSize=X(c.gridSize||y.layoutAlgorithm.gridSize,x.plotWidth),c.processedDistance=X(c.distance||y.layoutAlgorithm.distance,x.plotWidth),s=c.kmeansThreshold||y.layoutAlgorithm.kmeansThreshold;let I=c.processedGridSize/2,v=H(f,{x:0,y:0}),T=H(f,{x:I,y:I});r=Math.abs(v.x-T.x),o=Math.abs(v.y-T.y);for(let t=0;t<b.length;t++)!f.dataMaxX&&(k(n)&&k(a)&&k(u)&&k(l)?w(S[t])&&w(u)&&w(l)&&(n=Math.max(b[t],n),a=Math.min(b[t],a),u=Math.max(S[t]||u,u),l=Math.min(S[t]||l,l)):(n=a=b[t],u=l=S[t])),b[t]>=P.minX-r&&b[t]<=P.maxX+r&&(S[t]||P.minY)>=P.minY-o&&(S[t]||P.maxY)<=P.maxY+o&&(Y.push(b[t]),L.push(S[t]),O.push(t));if(k(n)&&k(a)&&w(u)&&w(l)&&(f.dataMaxX=n,f.dataMinX=a,f.dataMaxY=u,f.dataMinY=l),h=(d=(M(p)?p:f.markerClusterAlgorithms?p&&f.markerClusterAlgorithms[p]?f.markerClusterAlgorithms[p]:Y.length<s?f.markerClusterAlgorithms.kmeans:f.markerClusterAlgorithms.grid:()=>!1).call(this,Y,L,O,c))?f.getClusteredData(d,A):d,A.animation&&f.markerClusterInfo?.pointsState?.oldState){var D=f.markerClusterInfo.pointsState.oldState;for(let t of Object.keys(D))D[t].point?.destroy?.();t=f.markerClusterInfo.pointsState.newState}else t={};e=b.length,i=f.markerClusterInfo,h&&(f.dataTable.modified=new g({columns:{x:h.groupedXData,y:h.groupedYData}}),f.hasGroupedData=!0,f.markerClusterInfo=h,f.groupMap=h.groupMap),z.apply(this),h&&f.markerClusterInfo&&(f.markerClusterInfo.clusters?.forEach(t=>{(m=f.points[t.index]).isCluster=!0,m.clusteredData=t.data,m.clusterPointsAmount=t.data.length,t.point=m,C(m,"click",F)}),f.markerClusterInfo.noise?.forEach(t=>{t.point=f.points[t.index]}),A.animation&&f.markerClusterInfo&&(f.markerClusterInfo.pointsState={oldState:t,newState:f.getPointsState(h,i,e)}),A.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else z.apply(this)}function _(t,e,i){let s=[];for(let r=0;r<t.length;r++){let o=te(this,{x:e,y:i}),a=te(this,{x:t[r].posX,y:t[r].posY}),n=Math.sqrt(Math.pow(o.x-a.x,2)+Math.pow(o.y-a.y,2));s.push({clusterIndex:r,distance:n})}return s.sort((t,e)=>t.distance-e.distance)}function B(t,e){let i=this.options.data,s=[],r=[],o=[],a=[],n=[],l=Math.max(2,e.minimumClusterSize||2),u=0,p,h,d,c,m,f,g,x,C,k,w,P;if(M(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return I("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(let I in t)if(t[I].length>=l){if(d=t[I],p=E(),m=d.length,e.zones)for(let t=0;t<e.zones.length;t++)m>=e.zones[t].from&&m<=e.zones[t].to&&((w=e.zones[t]).zoneIndex=t,k=e.zones[t].marker,P=e.zones[t].className);C=V(d),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?g={x:C.x,y:C.y}:(f=this.options.marker||{},g=this.preventClusterCollisions({x:C.x,y:C.y,key:I,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:f.radius||3+(f.lineWidth||0),clusterRadius:k&&k.radius?k.radius:(e.marker||{}).radius||y.marker.radius}));for(let t=0;t<m;t++)d[t].parentStateId=p;if(o.push({x:g.x,y:g.y,id:I,stateId:p,index:u,data:d,clusterZone:w,clusterZoneClassName:P}),s.push(g.x),r.push(g.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:A(e.marker,{states:e.states},k||{})}}),i?.length)for(let t=0;t<m;t++)S(i[d[t].dataIndex])&&(d[t].options=i[d[t].dataIndex]);u++,k=null}else for(let e=0;e<t[I].length;e++)h=t[I][e],p=E(),x=null,c=i?.[h.dataIndex],s.push(h.x),r.push(h.y),h.parentStateId=p,a.push({x:h.x,y:h.y,id:I,stateId:p,index:u,data:t[I]}),x=c&&"object"==typeof c&&!b(c)?A(c,{x:h.x,y:h.y}):{userOptions:c,x:h.x,y:h.y},n.push({options:x}),u++;return{clusters:o,noise:a,groupedXData:s,groupedYData:r,groupMap:n}}function q(){let{chart:t,xAxis:e,yAxis:i}=this,s=0;return{plotLeft:s=e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function U(t,e,i){let s,r,o=e?j(e,i):[],a=j(t,i),n={};O=[],t.clusters.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<a.length;t++)s=a[t],r=o[t],s?.parentStateId&&r?.parentStateId&&n[s.parentStateId]?.parentsId.indexOf(r.parentStateId)===-1&&(n[s.parentStateId].parentsId.push(r.parentStateId),-1===O.indexOf(r.parentStateId)&&O.push(r.parentStateId));return n}function K(){let t=this.chart,e=t.mapView?0:t.plotLeft,i=H(this,{x:e,y:t.mapView?0:t.plotTop}),s=H(this,{x:e+t.plotWidth,y:e+t.plotHeight}),r=i.x,o=s.x,a=i.y,n=s.y;return{minX:Math.min(r,o),maxX:Math.max(r,o),minY:Math.min(a,n),maxY:Math.max(a,n)}}function $(t){let e=this.xAxis,i=this.chart.mapView,s=t.processedGridSize||y.layoutAlgorithm.gridSize,r=!0,o=1,a=1;this.gridValueSize||(i?this.gridValueSize=s/i.getScale():this.gridValueSize=Math.abs(e.toValue(s)-e.toValue(0)));let n=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);for(;r&&1!==n;){let t=Math.pow(2,o);n>.75&&n<1.25?r=!1:n>=1/t&&n<1/t*2?(r=!1,a=t):n<=t&&n>t/2&&(r=!1,a=1/t),o++}return s/a/n}function J(){let t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,i=O.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function Q(t){let e=!1;return!!S(t)&&(P(t,t=>{if(e=!0,!b(t)||!t.length){e=!1;return}for(let i=0;i<t.length;i++)if(!S(t[i])||!t[i].x||!t[i].y){e=!1;return}}),e)}function tt(t){let[e,i]=t.key.split(":").map(parseFloat),s=t.gridSize,r=t.groupedData,o=t.defaultRadius,a=t.clusterRadius,n=i*s,l=e*s,u=te(this,t),p=[],h=this.options.cluster?.marker,d=this.options.cluster?.zones,c=this.getGridOffset(),m=u.x,f=u.y,g=0,x=0,C,I,b,M,S,w,A,P,X,Y,L,z;m-=c.plotLeft,f-=c.plotTop;for(let r=1;r<5;r++)for(A=0,b=r%2?-1:1,M=r<3?-1:1,S=Math.floor((m+b*a)/s),z=[(w=Math.floor((f+M*a)/s))+":"+S,w+":"+i,e+":"+S];A<z.length;A++)-1===p.indexOf(z[A])&&z[A]!==t.key&&p.push(z[A]);for(let t of p)if(r[t]){r[t].posX||(Y=V(r[t]),r[t].posX=Y.x,r[t].posY=Y.y);let u=te(this,{x:r[t].posX||0,y:r[t].posY||0});if(C=u.x-c.plotLeft,I=u.y-c.plotTop,[X,P]=t.split(":").map(parseFloat),d){g=r[t].length;for(let t=0;t<d.length;t++)g>=d[t].from&&g<=d[t].to&&(x=k(d[t].marker?.radius)?d[t].marker.radius||0:h?.radius?h.radius:y.marker.radius)}r[t].length>1&&0===x&&h?.radius?x=h.radius:1===r[t].length&&(x=o),L=a+x,x=0,P!==i&&Math.abs(m-C)<L&&(m=P-i<0?n+a:n+s-a),X!==e&&Math.abs(f-I)<L&&(f=X-e<0?l+a:l+s-a)}let O=H(this,{x:m+c.plotLeft,y:f+c.plotTop});return r[t.key].posX=O.x,r[t.key].posY=O.y,O}function te(t,e){let{chart:i,xAxis:s,yAxis:r}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:r?r.toPixels(e.y):0}}let ti=function(t,e){let i=e.prototype;!i.markerClusterAlgorithms&&(z=i.generatePoints,i.markerClusterAlgorithms=L,i.animateClusterPoint=N,i.destroyClusteredData=W,i.generatePoints=Z,i.getClusterDistancesFromPoint=_,i.getClusteredData=B,i.getGridOffset=q,i.getPointsState=U,i.getRealExtremes=K,i.getScaledGridSize=$,i.hideClusteredData=J,i.isValidGroupedDataObject=Q,i.preventClusterCollisions=tt,C(e,"destroy",i.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=A(t.plotOptions.series,p)))},{animObject:ts}=u(),{defaultOptions:tr}=u(),{composed:to}=u(),{addEvent:ta,defined:tn,error:tl,isFunction:tu,merge:tp,pushUnique:th,syncTimeout:td}=u();function tc(){let t=this.chart,e=0;for(let i of t.series)i.markerClusterInfo&&(e=ts((i.options.cluster||{}).animation).duration||0);td(()=>{t.tooltip&&t.tooltip.destroy()},e)}function tm(){for(let t of this.series||[])if(t.markerClusterInfo){let e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===(t.chart.pointer?.pinchDown||[]).length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(let e of t.markerClusterInfo.clusters)t.animateClusterPoint(e);for(let e of t.markerClusterInfo.noise)t.animateClusterPoint(e)}}}function tf(t){let e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;tu(e)&&e.call(this,t)}function tg(){if(this.dataGroup)return tl("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function tx(){let t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(let e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),tn(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}function ty(t,i,s,r){let o=s/2,a=r/2,n=e.arc(t+o,i+a,o-4,a-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),l=e.arc(t+o,i+a,o-3,a-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o-2,open:!1});return e.arc(t+o,i+a,o-1,a-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:o,open:!1}).concat(l,n)}(tr.plotOptions||{}).series=tp((tr.plotOptions||{}).series,p);let tC=u();({compose:function(t,e,i,s){if(th(to,"MarkerClusters")){let r=s.prototype.pointClass,{scatter:o}=s.types;ta(t,"setExtremes",tc),ta(e,"render",tm),ta(r,"drillToCluster",tf),ta(r,"update",tg),ta(s,"afterRender",tx),o&&ti(i,o)}}}).compose(tC.Axis,tC.Chart,tC.defaultOptions,tC.Series),({compose:function(t){(e=t.prototype.symbols).cluster=ty}}).compose(tC.SVGRenderer);let tk=u();return n.default})());