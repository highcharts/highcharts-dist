import*as t from"../highcharts.js";var e={};e.n=t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},e.d=(t,i)=>{for(var s in i)e.o(i,s)&&!e.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:i[s]})},e.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let i=t.default;var s=e.n(i);let o=t.default.SeriesRegistry;var r=e.n(o);let{series:{prototype:{pointClass:a}},seriesTypes:{pie:{prototype:{pointClass:l}}}}=r(),{extend:n}=s();class h extends l{}n(h.prototype,{haloPath:a.prototype.haloPath});let{merge:d}=s(),c={endAngle:void 0,innerSize:"40%",itemPadding:.1,layout:"vertical",marker:d({lineWidth:2,allowPointSelect:!1,crisp:!0,showCheckbox:!1,animation:{duration:1e3},enableMouseTracking:!0,events:{},marker:{enabledThreshold:2,lineColor:"#ffffff",lineWidth:0,radius:4,states:{normal:{animation:!0},hover:{animation:{duration:150},enabled:!0,radiusPlus:2,lineWidthPlus:1},select:{fillColor:"#cccccc",lineColor:"#000000",lineWidth:2}}},point:{events:{}},dataLabels:{animation:{},align:"center",borderWidth:0,defer:!0,formatter:function(){let{numberFormatter:t}=this.series.chart;return"number"!=typeof this.y?"":t(this.y,-1)},padding:5,style:{fontSize:"0.7em",fontWeight:"bold",color:"contrast",textOutline:"1px contrast"},verticalAlign:"bottom",x:0,y:0},cropThreshold:300,opacity:1,pointRange:0,softThreshold:!0,states:{normal:{animation:!0},hover:{animation:{duration:150},lineWidthPlus:1,marker:{},halo:{size:10,opacity:.25}},select:{animation:{duration:0}},inactive:{animation:{duration:150},opacity:.2}},stickyTracking:!0,turboThreshold:1e3,findNearestPointBy:"x"}.marker,{radius:null}),rows:void 0,crisp:!1,showInLegend:!0,startAngle:void 0},{pie:p}=r().seriesTypes,{defined:g,extend:u,fireEvent:f,isNumber:m,merge:y,pick:b}=s();class v extends p{animate(t){let e=this.group;e&&(t?e.attr({opacity:0}):e.animate({opacity:1},this.options.animation))}drawDataLabels(){if(this.center&&this.slots)super.drawDataLabels();else for(let t of this.points)t.destroyElements({dataLabel:1})}drawPoints(){let t=this.options,e=this.chart.renderer,i=t.marker,s=this.borderWidth%2?.5:1,o=this.getRows(),r=Math.ceil(this.total/o),a=this.chart.plotWidth/r,l=this.chart.plotHeight/o,n=this.itemSize||Math.min(a,l),h=0;for(let d of this.points){let c,p,f,m,y,v,M=d.marker||{},w=M.symbol||i.symbol,A=b(M.radius,i.radius),P=g(A)?2*A:n,k=P*t.itemPadding;if(d.graphics=p=d.graphics||[],this.chart.styledMode||(f=this.pointAttribs(d,d.selected&&"select")),!d.isNull&&d.visible){d.graphic||(d.graphic=e.g("point").add(this.group));for(let i=0;i<(d.y||0);++i){if(this.center&&this.slots){let t=this.slots.shift();m=t.x-n/2,y=t.y-n/2}else"horizontal"===t.layout?(m=h%r*a,y=l*Math.floor(h/r)):(m=a*Math.floor(h/o),y=h%o*l);m+=k,y+=k,v=Math.round(P-2*k),this.options.crisp&&(m=Math.round(m)-s,y=Math.round(y)+s),c={x:m,y:y,width:v,height:v},void 0!==A&&(c.r=A),f&&u(c,f);let g=p[i];g?g.animate(c):g=e.symbol(w,void 0,void 0,void 0,void 0,{backgroundSize:"within"}).attr(c).add(d.graphic),g.isActive=!0,p[i]=g,++h}}for(let t=0;t<p.length;t++){let e=p[t];if(!e)return;e.isActive?e.isActive=!1:(e.destroy(),p.splice(t,1),t--)}}}getRows(){let t=this.chart,e=this.total||0,i=this.options.rows,s,o;if(!i){if(o=t.plotWidth/t.plotHeight,i=Math.sqrt(e),o>1)for(i=Math.ceil(i);i>0&&!(e/i/i>o);)i--;else for(i=Math.floor(i);i<e&&!(e/i/i<o);)i++}return i}getSlots(){let t=this.center,e=t[2],i=this.slots=this.slots||[],s=this.endAngleRad-this.startAngleRad,o=this.options.rows,r=s%(2*Math.PI)==0,a=this.total||0,l=t[3],n,h,d,c,p,g,u,f,m=0,y,b=Number.MAX_VALUE,v,M,w,A=(e-l)/e;for(;b>a+(M&&r?M.length:0);){v=b,i.length=0,b=0,M=w,w=[],y=e/++m/2,o?(l=(y-o)/y*e)>=0?y=o:(l=0,A=1):y=Math.floor(y*A);for(let t=y;t>0;t--)p=Math.ceil((c=s*(d=(l+t/y*(e-l-m))/2))/m),w.push({rowRadius:d,rowLength:c,colCount:p}),b+=p+1}if(!M)return;let P=v-this.total-(r?M.length:0),k=t=>{P>0&&(t.row.colCount--,P--)};for(;P>0;)M.map(t=>({angle:t.colCount/t.rowLength,row:t})).sort((t,e)=>e.angle-t.angle).slice(0,Math.min(P,Math.ceil(M.length/2))).forEach(k);for(let e of M){let o=e.rowRadius,r=e.colCount;for(f=0,g=r?s/r:0;f<=r;f+=1)u=this.startAngleRad+f*g,n=t[0]+Math.cos(u)*o,h=t[1]+Math.sin(u)*o,i.push({x:n,y:h,angle:u})}return i.sort((t,e)=>t.angle-e.angle),this.itemSize=m,i}translate(t){0===this.total&&m(this.options.startAngle)&&m(this.options.endAngle)&&(this.center=this.getCenter()),this.slots||(this.slots=[]),m(this.options.startAngle)&&m(this.options.endAngle)?(super.translate(t),this.slots=this.getSlots()):(this.generatePoints(),f(this,"afterTranslate"))}}v.defaultOptions=y(p.defaultOptions,c),u(v.prototype,{markerAttribs:void 0,pointClass:h}),r().registerSeriesType("item",v);let M=s();export{M as default};