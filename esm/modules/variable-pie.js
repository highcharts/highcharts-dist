/**
 * Highcharts JS v12.4.0 (2025-09-04)
 * @module highcharts/modules/variable-pie
 * @requires highcharts
 *
 * Variable Pie module for Highcharts
 *
 * (c) 2010-2025 Grzegorz Blachliński
 *
 * License: www.highcharts.com/license
 */import*as t from"../highcharts.js";var e={};e.n=t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},e.d=(t,i)=>{for(var a in i)e.o(i,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:i[a]})},e.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let i=t.default;var a=e.n(i);let s=t.default.SeriesRegistry;var n=e.n(s);let{pie:r}=n().seriesTypes,{arrayMax:l,arrayMin:o,clamp:h,extend:d,fireEvent:p,merge:c,pick:M}=a();class u extends r{calculateExtremes(){let t,e,i=this.chart,a=i.plotWidth,s=i.plotHeight,n=this.options,r=2*(n.slicedOffset||0),d=this.getColumn("z"),p=Math.min(a,s)-r,c={},u=this.center||this.getCenter();for(let t of["minPointSize","maxPointSize"]){let e=n[t],i=/%$/.test(e);e=parseInt(e,10),c[t]=i?p*e/100:2*e}this.minPxSize=u[3]+c.minPointSize,this.maxPxSize=h(u[2],u[3]+c.minPointSize,c.maxPointSize),d.length&&(t=M(n.zMin,o(d.filter(this.zValEval))),e=M(n.zMax,l(d.filter(this.zValEval))),this.getRadii(t,e,this.minPxSize,this.maxPxSize))}getRadii(t,e,i,a){let s,n,r,l=this.getColumn("z"),o=[],h="radius"!==this.options.sizeBy,d=e-t;for(let p=0;p<l.length;p++)(n=this.zValEval(l[p])?l[p]:t)<=t?r=i/2:n>=e?r=a/2:(s=d>0?(n-t)/d:.5,h&&(s=Math.sqrt(s)),r=Math.ceil(i+s*(a-i))/2),o.push(r);this.radii=o}redraw(){this.center=null,super.redraw()}getDataLabelPosition(t,e){let{center:i,options:a}=this,s=t.angle||0,n=this.radii[t.index],r=i[0]+Math.cos(s)*n,l=i[1]+Math.sin(s)*n,o=Math.min((a.slicedOffset||0)+(a.borderWidth||0),e/5);return{distance:e,natural:{x:r+Math.cos(s)*e,y:l+Math.sin(s)*e},computed:{},alignment:t.half?"right":"left",connectorPosition:{breakAt:{x:r+Math.cos(s)*o,y:l+Math.sin(s)*o},touchingSliceAt:{x:r,y:l}}}}translate(t){this.generatePoints();let e=this.options,i=e.slicedOffset,a=e.startAngle||0,s=Math.PI/180*(a-90),n=Math.PI/180*(M(e.endAngle,a+360)-90),r=n-s,l=this.points,o=e.ignoreHiddenPoint,h=0,d,c,u,g,z,f,P;this.startAngleRad=s,this.endAngleRad=n,this.calculateExtremes(),t||(this.center=t=this.getCenter());for(let e=0;e<l.length;e++)f=l[e],P=this.radii[e],d=s+h*r,(!o||f.visible)&&(h+=f.percentage/100),c=s+h*r,f.shapeType="arc",f.shapeArgs={x:t[0],y:t[1],r:P,innerR:t[3]/2,start:Math.round(1e3*d)/1e3,end:Math.round(1e3*c)/1e3},(u=(c+d)/2)>1.5*Math.PI?u-=2*Math.PI:u<-Math.PI/2&&(u+=2*Math.PI),f.slicedTranslation={translateX:Math.round(Math.cos(u)*i),translateY:Math.round(Math.sin(u)*i)},g=Math.cos(u)*t[2]/2,z=Math.sin(u)*t[2]/2,f.tooltipPos=[t[0]+.7*g,t[1]+.7*z],f.half=+(u<-Math.PI/2||u>Math.PI/2),f.angle=u;p(this,"afterTranslate")}zValEval(t){return!("number"!=typeof t||isNaN(t))||null}}u.defaultOptions=c(r.defaultOptions,{minPointSize:"10%",maxPointSize:"100%",zMin:void 0,zMax:void 0,sizeBy:"area",tooltip:{pointFormat:'<span style="color:{point.color}">●</span> {series.name}<br/>Value: {point.y}<br/>Size: {point.z}<br/>'}}),d(u.prototype,{pointArrayMap:["y","z"],parallelArrays:["x","y","z"]}),n().registerSeriesType("variablepie",u);let g=a();export{g as default};