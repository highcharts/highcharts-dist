import*as t from"../highcharts.js";var e={};e.n=t=>{var i=t&&t.__esModule?()=>t.default:()=>t;return e.d(i,{a:i}),i},e.d=(t,i)=>{for(var a in i)e.o(i,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:i[a]})},e.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let i=t.default;var a=e.n(i);let o=t.default.SeriesRegistry;var s=e.n(o);let{map:{prototype:{pointClass:r}}}=s().seriesTypes,{isNumber:n}=a(),l=class extends r{applyOptions(t,e){let i=super.applyOptions.call(this,t,e),{lat:a,lon:o}=i.options;if(n(o)&&n(a)){let{colsize:t=1,rowsize:e=1}=this.series.options,s=o-t/2,r=a-e/2;i.geometry=i.options.geometry={type:"Polygon",coordinates:[[[s,r],[s+t,r],[s+t,r+e],[s,r+e],[s,r]]]}}return i}},{doc:p}=a(),{defined:h,pick:d}=a(),{animObject:g,stop:c}=a(),{noop:u}=a(),{colorFromPoint:y,getContext:m}={colorFromPoint:function(t,e){let i=e.series.colorAxis;if(i){let a=i.toColor(t||0,e).split(")")[0].split("(")[1].split(",").map(t=>d(parseFloat(t),parseInt(t,10)));return a[3]=255*d(a[3],1),h(t)&&e.visible||(a[3]=0),a}return[0,0,0,0]},getContext:function(t){let{canvas:e,context:i}=t;return e&&i?(i.clearRect(0,0,e.width,e.height),i):(t.canvas=p.createElement("canvas"),t.context=t.canvas.getContext("2d",{willReadFrequently:!0})||void 0,t.context)}},{seriesTypes:{map:f}}=s(),{addEvent:b,error:x,extend:w,isNumber:D,isObject:v,merge:C,pick:P}=a();function I(t){return t-360*Math.floor((t+180)/360)}class T extends f{constructor(){super(...arguments),this.isDirtyCanvas=!0}update(){this.options=C(this.options,arguments[0]),this.getInterpolation().enabled&&(this.isDirtyCanvas=!0,this.points.forEach(t=>{t.graphic&&(t.graphic.destroy(),delete t.graphic)})),super.update.apply(this,arguments)}translate(){(!this.getInterpolation().enabled||!this.image||this.isDirty||this.isDirtyData)&&super.translate.apply(this,arguments)}getInterpolation(){return v(this.options.interpolation)?this.options.interpolation:{blur:1,enabled:this.options.interpolation}}drawPoints(){let t=this.chart.mapView,e=this.options;if(this.getInterpolation().enabled&&t&&this.bounds){let a=this.context||m(this),{canvas:o,colorAxis:s,image:r,chart:n,points:l}=this,[p,h]=[P(e.colsize,1),P(e.rowsize,1)],d=t.projectedUnitsToPixels({x:this.bounds.x1,y:this.bounds.y2}),u=t.projectedUnitsToPixels({x:this.bounds.x2,y:this.bounds.y1});if(o&&a&&s&&d&&u){let{x:e,y:s}=d,m=u.x-e,f=u.y-s,b={x:e,y:s,width:m,height:f};if(this.isDirtyCanvas||this.isDirtyData||"Orthographic"===t.projection.options.name){let r=o.width=~~(360/p)+1,n=o.height=~~(180/h)+1,d=new Uint8ClampedArray(r*n*4),{lat:g=0,lon:c=0}=l[0].options,u=c%h!=0,b=g%p!=0,w=u?t=>Math.round(t/h)*h:t=>t,v=b?t=>Math.round(t/p)*p:t=>t,C=l.length;(u||b)&&x("Highcharts Warning: For best performance, lon/lat datapoints should spaced by a single colsize/rowsize",!1,this.chart,{colsize:String(p),rowsize:String(h)}),this.directTouch=!1,this.isDirtyCanvas=!0;for(let t=0;t<C;t++){let e=l[t],{lon:a,lat:o}=e.options;if(D(a)&&D(o)){var i;d.set(y(e.value,e),4*(i=w(a),Math.ceil(r*(n-1-(v(o)+90)/h)+(i+180)/p)))}}let P=this.getInterpolation().blur,I=0===P?1:11*P,T=~~(r*I),j=~~(n*I),L=~~m,z=~~f,O=new ImageData(d,r,n);o.width=T,o.height=j,a.putImageData(O,0,0),a.globalCompositeOperation="copy",a.drawImage(o,0,0,O.width,O.height,0,0,T,j);let U=this.getProjectedImageData(t,L,z,a.getImageData(0,0,T,j),o,e,s);o.width=L,o.height=z,a.putImageData(new ImageData(U,L,z),0,0)}if(r){if(n.renderer.globalAnimation&&n.hasRendered){let t=Number(r.attr("x")),i=Number(r.attr("y")),a=Number(r.attr("width")),l=Number(r.attr("height")),p=(o,n)=>{let p=n.pos;r.attr({x:t+(e-t)*p,y:i+(s-i)*p,width:a+(m-a)*p,height:l+(f-l)*p})},h=C(g(n.renderer.globalAnimation)),d=h.step;h.step=function(){d&&d.apply(this,arguments),p.apply(this,arguments)},r.attr(C({animator:0},this.isDirtyCanvas?{href:o.toDataURL("image/png",1)}:void 0)).animate({animator:1},h)}else c(r),r.attr(C(b,this.isDirtyCanvas?{href:o.toDataURL("image/png",1)}:void 0))}else this.image=n.renderer.image(o.toDataURL("image/png",1)).attr(b).add(this.group);this.isDirtyCanvas=!1}}else super.drawPoints.apply(this,arguments)}getProjectedImageData(t,e,i,a,o,s,r){let n=new Uint8ClampedArray(e*i*4),l=P(t.projection.options.rotation?.[0],0),p=o.width/360,h=-1*o.height/180,d=-1;for(let i=0;i<n.length;i+=4){let g=i/4%e;0===g&&d++;let c=t.pixelsToLonLat({x:s+g,y:r+d});if(c){c.lon>-180-l&&c.lon<180-l&&(c.lon=I(c.lon));let t=[c.lon,c.lat],e=t[0]*p+o.width/2,s=t[1]*h+o.height/2;if(e>=0&&e<=o.width&&s>=0&&s<=o.height){let t=Math.floor(s)*o.width*4+4*Math.round(e);n[i]=a.data[t],n[i+1]=a.data[t+1],n[i+2]=a.data[t+2],n[i+3]=a.data[t+3]}}}return n}searchPoint(t,e){let i=this.chart,a=i.mapView;if(a&&this.bounds&&this.image&&i.tooltip&&i.tooltip.options.enabled){if(!i.pointer.hasDragged&&(.01>=+this.image.attr("animator")||+this.image.attr("animator")>=.99)){let o=a.projectedUnitsToPixels({x:this.bounds.x1,y:this.bounds.y2}),s=a.projectedUnitsToPixels({x:this.bounds.x2,y:this.bounds.y1});if(i.pointer.normalize(t),t.lon&&t.lat&&o&&s&&t.chartX-i.plotLeft>o.x&&t.chartX-i.plotLeft<s.x&&t.chartY-i.plotTop>o.y&&t.chartY-i.plotTop<s.y)return this.searchKDTree({clientX:t.chartX,lon:I(t.lon),lat:t.lat},e,t)}else i.tooltip.destroy()}}}T.defaultOptions=C(f.defaultOptions,{nullColor:"transparent",tooltip:{pointFormat:"Lat: {point.lat}, Lon: {point.lon}, Value: {point.value}<br/>"},borderWidth:0,colsize:1,rowsize:1,stickyTracking:!0,interpolation:{enabled:!1,blur:1}}),b(T,"afterDataClassLegendClick",function(){this.isDirtyCanvas=!0,this.drawPoints()}),w(T.prototype,{type:"geoheatmap",applyJitter:u,pointClass:l,pointArrayMap:["lon","lat","value"],kdAxisArray:["lon","lat"]}),s().registerSeriesType("geoheatmap",T);let j=a();export{j as default};