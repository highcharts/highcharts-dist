/**
 * Highcharts JS v12.4.0 (2025-09-04)
 * @module highcharts/modules/flowmap
 * @requires highcharts
 *
 * (c) 2009-2025
 *
 * License: www.highcharts.com/license
 */import*as t from"../highcharts.js";var o={};o.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return o.d(e,{a:e}),e},o.d=(t,e)=>{for(var i in e)o.o(e,i)&&!o.o(t,i)&&Object.defineProperty(t,i,{enumerable:!0,get:e[i]})},o.o=(t,o)=>Object.prototype.hasOwnProperty.call(t,o);let e=t.default;var i=o.n(e);let s=t.default.SeriesRegistry;var r=o.n(s);let{seriesTypes:{mapline:{prototype:{pointClass:n}}}}=r(),{pick:a,isString:p,isNumber:l}=i(),h=class extends n{isValid(){let t=!!(this.options.to&&this.options.from);return[this.options.to,this.options.from].forEach(function(o){t=!!(t&&o&&(p(o)||l(a(o[0],o.lat))&&l(a(o[1],o.lon))))}),t}},{series:{prototype:{pointClass:d}},seriesTypes:{column:f,map:m,mapline:g}}=r(),{addEvent:y,arrayMax:c,arrayMin:u,defined:w,extend:x,isArray:P,merge:b,pick:L,relativeLength:W}=i();class k extends g{static getLength(t,o){return Math.sqrt(t*t+o*o)}static normalize(t,o){let e=this.getLength(t,o);return[t/e,o/e]}static markerEndPath(t,o,e,i){let s=W(i.width||0,this.getLength(o[0]-t[0],o[1]-t[1])),r=i.markerType||"arrow",[n,a]=this.normalize(o[0]-t[0],o[1]-t[1]),p=[];if("arrow"===r){let[i,r]=t;i-=n*s,r-=a*s,p.push(["L",i,r]),p.push(["L",e[0],e[1]]),[i,r]=o,i+=n*s,r+=a*s,p.push(["L",i,r])}if("mushroom"===r){let[i,r]=t,[l,h]=o,[d,f]=e,m=(l-i)/2+i,g=(h-r)/2+r;i-=n*s,r-=a*s,p.push(["L",i,r]),l+=n*s,h+=a*s,p.push(["Q",(d-m)*2+m,(f-g)*2+g,l,h])}return p}animate(t){let o=this.points;t||o.forEach(t=>{if(t.shapeArgs&&P(t.shapeArgs.d)&&t.shapeArgs.d.length){let o=t.shapeArgs.d,e=o[0][1],i=o[0][2];if(e&&i){let s=[];for(let t=0;t<o.length;t++){s.push([...o[t]]);for(let r=1;r<o[t].length;r++)s[t][r]=r%2?e:i}t.graphic&&(t.graphic.attr({d:s}),t.graphic.animate({d:o}))}}})}getLinkWidth(t){let o=this.options.width,e=t.options.weight||this.options.weight;if(t.options.weight=e,o&&!e)return o;let i=this.smallestWeight,s=this.greatestWeight;if(!w(e)||!i||!s)return 0;let r=this.options.minWidth;return(e-i)*(this.options.maxWidth-r)/(s-i||1)+r}autoCurve(t,o,e,i,s,r){let n={x:e-t,y:i-o},a={x:(e-t)/2+t,y:(i-o)/2+o},p={x:a.x-s,y:a.y-r},l=n.x*p.x+n.y*p.y,h=Math.atan2(n.x*p.y-n.y*p.x,l),d=180*h/Math.PI;return d<0&&(d=360+d),-(.7*Math.sin(h=d*Math.PI/180))}pointAttribs(t,o){let e=m.prototype.pointAttribs.call(this,t,o);return e.fill=L(t.options.fillColor,t.options.color,"none"===this.options.fillColor?null:this.options.fillColor,this.color),e["fill-opacity"]=L(t.options.fillOpacity,this.options.fillOpacity),e["stroke-width"]=L(t.options.lineWidth,this.options.lineWidth,1),t.options.opacity&&(e.opacity=t.options.opacity),e}translate(){this.chart.hasRendered&&(this.isDirtyData||!this.hasRendered)&&(this.processData(),this.generatePoints());let t=[],o=0,e=0;this.points.forEach(i=>{let s,r,n=this.chart,a=n.mapView,p=i.options,l=()=>{i.series.isDirty=!0},h=t=>{let o=n.get(t);if(o instanceof d&&o.plotX&&o.plotY)return y(o,"update",l),{x:o.plotX,y:o.plotY}},f=t=>P(t)?{lon:t[0],lat:t[1]}:t;"string"==typeof p.from?s=h(p.from):"object"==typeof p.from&&a&&(s=a.lonLatToPixels(f(p.from))),"string"==typeof p.to?r=h(p.to):"object"==typeof p.to&&a&&(r=a.lonLatToPixels(f(p.to))),i.fromPos=s,i.toPos=r,s&&r&&(o+=(s.x+r.x)/2,e+=(s.y+r.y)/2),L(i.options.weight,this.options.weight)&&t.push(L(i.options.weight,this.options.weight))}),this.smallestWeight=u(t),this.greatestWeight=c(t),this.centerOfPoints={x:o/this.points.length,y:e/this.points.length},this.points.forEach(t=>{if(!this.getLinkWidth(t)){t.shapeArgs={d:[]};return}t.fromPos&&(t.plotX=t.fromPos.x,t.plotY=t.fromPos.y),t.shapeType="path",t.shapeArgs=this.getPointShapeArgs(t),t.color=L(t.options.color,t.series.color)})}getPointShapeArgs(t){let{fromPos:o,toPos:e}=t;if(!o||!e)return{};let i=this.getLinkWidth(t)/2,s=t.options,r=b(this.options.markerEnd,s.markerEnd),n=L(s.growTowards,this.options.growTowards),a=o.x||0,p=o.y||0,l=e.x||0,h=e.y||0,d=L(s.curveFactor,this.options.curveFactor),f=r&&r.enabled&&r.height||0;if(w(d)||(d=this.autoCurve(a,p,l,h,this.centerOfPoints.x,this.centerOfPoints.y)),f){f=W(f,4*i);let t=l-a,o=h-p,e=a+(t*=.5),s=p+(o*=.5),r=t,n=e+(t=o)*d,m=s+(o=-r)*d,[g,y]=k.normalize(n-l,m-h);g*=f,y*=f,l+=g,h+=y}let m=l-a,g=h-p,y=a+(m*=.5),c=p+(g*=.5),u=m;m=g,g=-u;let[x,P]=k.normalize(m,g),A=1+.25*Math.sqrt(d*d);x*=i*A,P*=i*A;let O=y+m*d,v=c+g*d,[C,M]=k.normalize(O-a,v-p);u=C,C=M,M=-u,C*=i,M*=i;let[T,E]=k.normalize(O-l,v-h);u=T,T=-E,E=u,T*=i,E*=i,n&&(C/=i,M/=i,x/=4,P/=4);let z={d:[["M",a-C,p-M],["Q",O-x,v-P,l-T,h-E],["L",l+T,h+E],["Q",O+x,v+P,a+C,p+M],["Z"]]};if(r&&r.enabled&&z.d){let t=k.markerEndPath([l-T,h-E],[l+T,h+E],[e.x,e.y],r);z.d.splice(2,0,...t)}let j=t.options.from,D=t.options.to,F=j.lat,S=j.lon,$=D.lat,Q=D.lon;return F&&S&&(t.options.from=`${+F}, ${+S}`),$&&Q&&(t.options.to=`${+$}, ${+Q}`),z}}k.defaultOptions=b(g.defaultOptions,{animation:!0,dataLabels:{enabled:!1},fillOpacity:.5,markerEnd:{enabled:!0,height:"40%",width:"40%",markerType:"arrow"},width:1,maxWidth:25,minWidth:5,lineWidth:void 0,tooltip:{headerFormat:'<span style="font-size: 0.8em">{series.name}</span><br/>',pointFormat:"{point.options.from} â†’ {point.options.to}: <b>{point.options.weight}</b>"}}),x(k.prototype,{pointClass:h,pointArrayMap:["from","to","weight"],drawPoints:f.prototype.drawPoints,dataColumnKeys:f.prototype.dataColumnKeys,useMapGeometry:!0}),r().registerSeriesType("flowmap",k);let A=i();export{A as default};