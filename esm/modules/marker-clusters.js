let t;/**
 * Highcharts JS v12.5.0-modified (2026-02-21)
 * @module highcharts/modules/marker-clusters
 * @requires highcharts
 *
 * Marker clusters module for Highcharts
 *
 * (c) 2010-2026 Highsoft AS
 * Author: Wojciech Chmiel
 *
 * A commercial license may be required depending on use.
 * See www.highcharts.com/license
 */import*as e from"../highcharts.js";var i={};i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let s=e.default;var a=i.n(s);let r={cluster:{enabled:!1,allowOverlap:!0,animation:{duration:500},drillToCluster:!0,minimumClusterSize:2,layoutAlgorithm:{gridSize:50,distance:40,kmeansThreshold:100},marker:{symbol:"cluster",radius:15,lineWidth:0,lineColor:"#ffffff"},dataLabels:{enabled:!0,format:"{point.clusterPointsAmount}",verticalAlign:"middle",align:"center",style:{color:"contrast"},inside:!0}},tooltip:{clusterFormat:"<span>Clustered points: {point.clusterPointsAmount}</span><br/>"}},{setLength:o,splice:n}={convertToNumber:function(t,e){switch(typeof t){case"boolean":return+!!t;case"number":return isNaN(t)&&!e?null:t;default:return isNaN(t=parseFloat(`${t??""}`))&&!e?null:t}},setLength:function(t,e,i){return Array.isArray(t)?(t.length=e,t):t[i?"subarray":"slice"](0,e)},splice:function(t,e,i,s,a=[]){if(Array.isArray(t))return Array.isArray(a)||(a=Array.from(a)),{removed:t.splice(e,i,...a),array:t};let r=Object.getPrototypeOf(t).constructor,o=t[s?"subarray":"slice"](e,e+i),n=new r(t.length-i+a.length);return n.set(t.subarray(0,e),0),n.set(a,e),n.set(t.subarray(e+i),e+a.length),{removed:o,array:n}}},{fireEvent:l,objectEach:u,uniqueKey:p}=a(),h=class{constructor(t={}){this.autoId=!t.id,this.columns={},this.id=t.id||p(),this.rowCount=0,this.versionTag=p();let e=0;u(t.columns||{},(t,i)=>{this.columns[i]=t.slice(),e=Math.max(e,t.length)}),this.applyRowCount(e)}applyRowCount(t){this.rowCount=t,u(this.columns,(e,i)=>{e.length!==t&&(this.columns[i]=o(e,t))})}deleteRows(t,e=1){if(e>0&&t<this.rowCount){let i=0;u(this.columns,(s,a)=>{this.columns[a]=n(s,t,e).array,i=s.length}),this.rowCount=i}l(this,"afterDeleteRows",{rowIndex:t,rowCount:e}),this.versionTag=p()}getColumn(t,e){return this.columns[t]}getColumns(t,e){return(t||Object.keys(this.columns)).reduce((t,e)=>(t[e]=this.columns[e],t),{})}getRow(t,e){return(e||Object.keys(this.columns)).map(e=>this.columns[e]?.[t])}setColumn(t,e=[],i=0,s){this.setColumns({[t]:e},i,s)}setColumns(t,e,i){let s=this.rowCount;u(t,(t,e)=>{this.columns[e]=t.slice(),s=t.length}),this.applyRowCount(s),i?.silent||(l(this,"afterSetColumns"),this.versionTag=p())}setRow(t,e=this.rowCount,i,s){let{columns:a}=this,r=i?this.rowCount+1:e+1,o=Object.keys(t);if(s?.addColumns!==!1)for(let t=0,e=o.length;t<e;t++){let e=o[t];a[e]||(a[e]=[])}u(a,(o,l)=>{o||s?.addColumns===!1||(o=Array(r)),o&&(i?o=n(o,e,0,!0,[t[l]??null]).array:o[e]=t[l]??null,a[l]=o)}),r>this.rowCount&&this.applyRowCount(r),s?.silent||(l(this,"afterSetRows"),this.versionTag=p())}getModified(){return this.modified||this}},{animObject:d}=a(),{cluster:c}=r,{addEvent:m,defined:f,error:g,isArray:x,isFunction:y,isObject:C,isNumber:k,merge:I,objectEach:b,relativeLength:M,syncTimeout:S}=a(),w={grid:function(t,e,i,s){let a,r,o,n,l,u={},p=this.getGridOffset(),h=this.getScaledGridSize(s);for(l=0;l<t.length;l++){let s=K(this,{x:t[l],y:e[l]});a=s.x-p.plotLeft,r=s.y-p.plotTop,o=Math.floor(a/h),u[n=Math.floor(r/h)+":"+o]??(u[n]=[]),u[n].push({dataIndex:i[l],x:t[l],y:e[l]})}return u},kmeans:function(t,e,i,s){let a=[],r=[],o={},n=Number(s.processedDistance??M(s.distance||c.layoutAlgorithm.distance,this.chart.plotWidth)),l=s.iterations,u=0,p=!0,h=0,d=0,m,f=[];s.processedGridSize=n;let g=this.markerClusterAlgorithms?this.markerClusterAlgorithms.grid.call(this,t,e,i,s):{};for(let t in g)g[t].length>1&&(m=O(g[t]),a.push({posX:m.x,posY:m.y,oldX:0,oldY:0,startPointsLen:g[t].length,points:[]}));for(;p;){for(let t of a)t.points.length=0;r.length=0;for(let s=0;s<t.length;s++)h=t[s],d=e[s],(f=this.getClusterDistancesFromPoint(a,h,d)).length&&f[0].distance<n?a[f[0].clusterIndex].points.push({x:h,y:d,dataIndex:i[s]}):r.push({x:h,y:d,dataIndex:i[s]});for(let t=0;t<a.length;t++)1===a[t].points.length&&(f=this.getClusterDistancesFromPoint(a,a[t].points[0].x,a[t].points[0].y))[1].distance<n&&(a[f[1].clusterIndex].points.push(a[t].points[0]),a[f[0].clusterIndex].points.length=0);p=!1;for(let t=0;t<a.length;t++)m=O(a[t].points),a[t].oldX=a[t].posX,a[t].oldY=a[t].posY,a[t].posX=m.x,a[t].posY=m.y,(a[t].posX>a[t].oldX+1||a[t].posX<a[t].oldX-1||a[t].posY>a[t].oldY+1||a[t].posY<a[t].oldY-1)&&(p=!0);l&&(p=u<l-1),u++}for(let t=0,e=a.length;t<e;++t)o["cluster"+t]=a[t].points;for(let t=0,e=r.length;t<e;++t)o["noise"+t]=[r[t]];return o},optimizedKmeans:function(t,e,i,s){let a=Number(s.processedDistance??M(s.distance||c.layoutAlgorithm.gridSize,this.chart.plotWidth)),r=this.getRealExtremes(),o=(this.options.cluster||{}).marker,n,l={};if(!this.markerClusterInfo||this.initMaxX&&this.initMaxX<r.maxX||this.initMinX&&this.initMinX>r.minX||this.initMaxY&&this.initMaxY<r.maxY||this.initMinY&&this.initMinY>r.minY)this.initMaxX=r.maxX,this.initMinX=r.minX,this.initMaxY=r.maxY,this.initMinY=r.minY,l=this.markerClusterAlgorithms?this.markerClusterAlgorithms.kmeans.call(this,t,e,i,s):{},this.baseClusters=null;else{for(let t of(this.baseClusters??(this.baseClusters={clusters:this.markerClusterInfo.clusters,noise:this.markerClusterInfo.noise}),this.baseClusters.clusters)){for(let e of(t.pointsOutside=[],t.pointsInside=[],t.data)){let i=K(this,e),s=K(this,t);n=Math.sqrt(Math.pow(i.x-s.x,2)+Math.pow(i.y-s.y,2));let r=t.clusterZone?.marker?.radius??o?.radius??c.marker.radius??0,l=a-r>=0?a-r:r;n>r+l&&f(t.pointsOutside)?t.pointsOutside.push(e):f(t.pointsInside)&&t.pointsInside.push(e)}t.pointsInside.length&&(l[t.id]=t.pointsInside);let e=0;for(let i of t.pointsOutside)l[t.id+"_noise"+e++]=[i]}for(let t of this.baseClusters.noise)l[t.id]=t.data}return l}},A,P=[],X=0;function Y(t,e,i){t.attr({opacity:e}).animate({opacity:1},i)}function L(t,e,i,s){for(let a of(z(t,s,i,!0,!0),e))a.point?.destroy?.()}function z(t,e,i,s,a){t.point&&(s&&t.point.graphic&&(t.point.graphic.show(),Y(t.point.graphic,e,i)),a&&t.point.dataLabel&&(t.point.dataLabel.show(),Y(t.point.dataLabel,e,i)))}function O(t){let e=t.length,i=0,s=0;for(let a=0;a<e;a++)i+=t[a].x,s+=t[a].y;return{x:i/e,y:s/e}}function D(t,e){let i=[];return i.length=e,t.clusters.forEach(function(t){t.data.forEach(function(t){i[t.dataIndex]=t})}),t.noise.forEach(function(t){i[t.data[0].dataIndex]=t.data[0]}),i}function T(){return Math.random().toString(36).substring(2,7)+"-"+X++}function v(t,e,i){t.point&&(e&&t.point.graphic&&t.point.graphic.hide(),i&&t.point.dataLabel&&t.point.dataLabel.hide())}function R(t){(t.point||t.target).firePointEvent("drillToCluster",t,function(t){let e=t.point||t.target,i=e.series,{xAxis:s,yAxis:a,chart:r}=i,{inverted:o,mapView:n,pointer:l}=r;if(i.options.cluster?.drillToCluster&&e.clusteredData){let t=e.clusteredData.map(t=>t.x).sort((t,e)=>t-e),i=e.clusteredData.map(t=>t.y).sort((t,e)=>t-e),u=t[0],p=t[t.length-1],h=i[0],d=i[i.length-1],c=Math.abs((p-u)*.1),m=Math.abs((d-h)*.1),f=Math.min(u,p)-c,g=Math.max(u,p)+c,x=Math.min(h,d)-m,y=Math.max(h,d)+m;if(n)n.fitToBounds({x1:f,x2:g,y1:x,y2:y});else if(s&&a){let t=s.toPixels(f),e=s.toPixels(g),i=a.toPixels(x),n=a.toPixels(y);o&&([t,e,i,n]=[i,n,t,e]),t>e&&([t,e]=[e,t]),i>n&&([i,n]=[n,i]),l&&(l.zoomX=!0,l.zoomY=!0),r.transform({from:{x:t,y:i,width:e-t,height:n-i}})}}})}function V(t,e){let{chart:i,xAxis:s,yAxis:a}=t;return i.mapView?i.mapView.pixelsToProjectedUnits(e):{x:s?s.toValue(e.x):0,y:a?a.toValue(e.y):0}}function E(t){let e=this.chart,i=e.mapView,s=d(this.options.cluster?.animation),a=s.duration||500,r=this.markerClusterInfo?.pointsState,o=r?.newState,n=r?.oldState,l=[],u,p,h,c=0,m=0,f=0,g=!1,x=!1;if(n&&o){let r=K(this,p=o[t.stateId]);m=r.x-(i?0:e.plotLeft),f=r.y-(i?0:e.plotTop),1===p.parentsId.length?(u=n[o?.[t.stateId].parentsId[0]],p.point?.graphic&&u.point?.plotX&&u.point.plotY&&(u.point.plotX!==p.point.plotX||u.point.plotY!==p.point.plotY)&&(h=p.point.graphic.getBBox(),c=p.point.graphic?.isImg?0:h.width/2,p.point.graphic.attr({x:u.point.plotX-c,y:u.point.plotY-c}),p.point.graphic.animate({x:m-(p.point.graphic.radius||0),y:f-(p.point.graphic.radius||0)},s,function(){x=!0,u.point?.destroy?.()}),p.point.dataLabel?.alignAttr&&u.point.dataLabel?.alignAttr&&(p.point.dataLabel.attr({x:u.point.dataLabel.alignAttr.x,y:u.point.dataLabel.alignAttr.y}),p.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y},s)))):0===p.parentsId.length?(v(p,!0,!0),S(function(){z(p,.1,s,!0,!0)},a/2)):(v(p,!0,!0),p.parentsId.forEach(function(t){n?.[t]&&(u=n[t],l.push(u),u.point?.graphic&&(g=!0,u.point.graphic.show(),u.point.graphic.animate({x:m-(u.point.graphic.radius||0),y:f-(u.point.graphic.radius||0),opacity:.4},s,function(){x=!0,L(p,l,s,.7)}),u.point.dataLabel&&-9999!==u.point.dataLabel.y&&p.point?.dataLabel?.alignAttr&&(u.point.dataLabel.show(),u.point.dataLabel.animate({x:p.point.dataLabel.alignAttr.x,y:p.point.dataLabel.alignAttr.y,opacity:.4},s))))}),S(function(){x||L(p,l,s,.85)},a),g||S(function(){L(p,l,s,.1)},a/2))}}function j(){this.markerClusterSeriesData?.forEach(t=>{t?.destroy?.()}),this.markerClusterSeriesData=null}function G(){let t,e,i,s,a,r,o,n,l,u,p,d,g,x,C,I=this,{chart:b}=I,S=b.mapView,w=I.getColumn("x"),P=I.getColumn("y"),X=I.options.cluster,Y=I.getRealExtremes(),L=[],z=[],O=[];if(S&&I.is("mappoint")&&w&&P&&I.options.data?.forEach((t,e)=>{let i=I.projectPoint(t);i&&(w[e]=i.x,P[e]=i.y)}),X?.enabled&&w?.length&&P?.length&&!b.polar){p=X.layoutAlgorithm.type,(x=X.layoutAlgorithm).processedGridSize=M(x.gridSize||c.layoutAlgorithm.gridSize,b.plotWidth),x.processedDistance=M(x.distance||c.layoutAlgorithm.distance,b.plotWidth),s=x.kmeansThreshold||c.layoutAlgorithm.kmeansThreshold;let S=x.processedGridSize/2,T=V(I,{x:0,y:0}),v=V(I,{x:S,y:S});a=Math.abs(T.x-v.x),r=Math.abs(T.y-v.y);for(let t=0;t<w.length;t++)!I.dataMaxX&&(f(n)&&f(o)&&f(u)&&f(l)?k(P[t])&&k(u)&&k(l)&&(n=Math.max(w[t],n),o=Math.min(w[t],o),u=Math.max(P[t]||u,u),l=Math.min(P[t]||l,l)):(n=o=w[t],u=l=P[t])),w[t]>=Y.minX-a&&w[t]<=Y.maxX+a&&(P[t]||Y.minY)>=Y.minY-r&&(P[t]||Y.maxY)<=Y.maxY+r&&(L.push(w[t]),z.push(P[t]),O.push(t));if(f(n)&&f(o)&&k(u)&&k(l)&&(I.dataMaxX=n,I.dataMinX=o,I.dataMaxY=u,I.dataMinY=l),d=(g=(y(p)?p:I.markerClusterAlgorithms?p&&I.markerClusterAlgorithms[p]?I.markerClusterAlgorithms[p]:L.length<s?I.markerClusterAlgorithms.kmeans:I.markerClusterAlgorithms.grid:()=>!1).call(this,L,z,O,x))?I.getClusteredData(g,X):g,X.animation&&I.markerClusterInfo?.pointsState?.oldState){var D=I.markerClusterInfo.pointsState.oldState;for(let t of Object.keys(D))D[t].point?.destroy?.();t=I.markerClusterInfo.pointsState.newState}else t={};e=w.length,i=I.markerClusterInfo,d&&(I.dataTable.modified=new h({columns:{x:d.groupedXData,y:d.groupedYData}}),I.hasGroupedData=!0,I.markerClusterInfo=d,I.groupMap=d.groupMap),A.apply(this),d&&I.markerClusterInfo&&(I.markerClusterInfo.clusters?.forEach(t=>{(C=I.points[t.index]).isCluster=!0,C.clusteredData=t.data,C.clusterPointsAmount=t.data.length,t.point=C,m(C,"click",R)}),I.markerClusterInfo.noise?.forEach(t=>{t.point=I.points[t.index]}),X.animation&&I.markerClusterInfo&&(I.markerClusterInfo.pointsState={oldState:t,newState:I.getPointsState(d,i,e)}),X.animation?this.hideClusteredData():this.destroyClusteredData(),this.markerClusterSeriesData=this.hasGroupedData?this.points:null)}else A.apply(this)}function N(t,e,i){let s=[];for(let a=0;a<t.length;a++){let r=K(this,{x:e,y:i}),o=K(this,{x:t[a].posX,y:t[a].posY}),n=Math.sqrt(Math.pow(r.x-o.x,2)+Math.pow(r.y-o.y,2));s.push({clusterIndex:a,distance:n})}return s.sort((t,e)=>t.distance-e.distance)}function F(t,e){let i=this.options.data,s=[],a=[],r=[],o=[],n=[],l=Math.max(2,e.minimumClusterSize||2),u=0,p,h,d,m,f,k,b,M,S,w,A,P;if(y(e.layoutAlgorithm.type)&&!this.isValidGroupedDataObject(t))return g("Highcharts marker-clusters module: The custom algorithm result is not valid!",!1,this.chart),!1;for(let g in t)if(t[g].length>=l){if(d=t[g],p=T(),f=d.length,e.zones)for(let t=0;t<e.zones.length;t++)f>=e.zones[t].from&&f<=e.zones[t].to&&((A=e.zones[t]).zoneIndex=t,w=e.zones[t].marker,P=e.zones[t].className);S=O(d),"grid"!==e.layoutAlgorithm.type||e.allowOverlap?b={x:S.x,y:S.y}:(k=this.options.marker||{},b=this.preventClusterCollisions({x:S.x,y:S.y,key:g,groupedData:t,gridSize:this.getScaledGridSize(e.layoutAlgorithm),defaultRadius:k.radius||3+(k.lineWidth||0),clusterRadius:w?.radius??e.marker?.radius??c.marker.radius??0}));for(let t=0;t<f;t++)d[t].parentStateId=p;if(r.push({x:b.x,y:b.y,id:g,stateId:p,index:u,data:d,clusterZone:A,clusterZoneClassName:P}),s.push(b.x),a.push(b.y),n.push({options:{formatPrefix:"cluster",dataLabels:e.dataLabels,marker:I(e.marker,{states:e.states},w||{})}}),i?.length)for(let t=0;t<f;t++)C(i[d[t].dataIndex])&&(d[t].options=i[d[t].dataIndex]);u++,w=null}else for(let e=0;e<t[g].length;e++)h=t[g][e],p=T(),M=null,m=i?.[h.dataIndex],s.push(h.x),a.push(h.y),h.parentStateId=p,o.push({x:h.x,y:h.y,id:g,stateId:p,index:u,data:t[g]}),M=m&&"object"==typeof m&&!x(m)?I(m,{x:h.x,y:h.y}):{userOptions:m,x:h.x,y:h.y},n.push({options:M}),u++;return{clusters:r,noise:o,groupedXData:s,groupedYData:a,groupMap:n}}function W(){let{chart:t,xAxis:e,yAxis:i}=this,s=0;return{plotLeft:s=e&&this.dataMinX&&this.dataMaxX?e.reversed?e.toPixels(this.dataMaxX):e.toPixels(this.dataMinX):t.plotLeft,plotTop:i&&this.dataMinY&&this.dataMaxY?i.reversed?i.toPixels(this.dataMinY):i.toPixels(this.dataMaxY):t.plotTop}}function _(t,e,i){let s,a,r=e?D(e,i):[],o=D(t,i),n={};P=[],t.clusters.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}}),t.noise.forEach(t=>{n[t.stateId]={x:t.x,y:t.y,id:t.stateId,point:t.point,parentsId:[]}});for(let t=0;t<o.length;t++)s=o[t],a=r[t],s?.parentStateId&&a?.parentStateId&&n[s.parentStateId]?.parentsId.indexOf(a.parentStateId)===-1&&(n[s.parentStateId].parentsId.push(a.parentStateId),-1===P.indexOf(a.parentStateId)&&P.push(a.parentStateId));return n}function Z(){let t=this.chart,e=t.mapView?0:t.plotLeft,i=V(this,{x:e,y:t.mapView?0:t.plotTop}),s=V(this,{x:e+t.plotWidth,y:e+t.plotHeight}),a=i.x,r=s.x,o=i.y,n=s.y;return{minX:Math.min(a,r),maxX:Math.max(a,r),minY:Math.min(o,n),maxY:Math.max(o,n)}}function B(t){let e=this.xAxis,i=this.chart.mapView,s=Number(t.processedGridSize??M(t.gridSize||c.layoutAlgorithm.gridSize,this.chart.plotWidth)),a=!0,r=1,o=1;this.gridValueSize||(i?this.gridValueSize=s/i.getScale():this.gridValueSize=Math.abs(e.toValue(s)-e.toValue(0)));let n=+(s/(i?this.gridValueSize*i.getScale():e.toPixels(this.gridValueSize)-e.toPixels(0))).toFixed(14);for(;a&&1!==n;){let t=Math.pow(2,r);n>.75&&n<1.25?a=!1:n>=1/t&&n<1/t*2?(a=!1,o=t):n<=t&&n>t/2&&(a=!1,o=1/t),r++}return s/o/n}function H(){let t=this.markerClusterSeriesData,e=this.markerClusterInfo?.pointsState?.oldState,i=P.map(t=>e?.[t].point?.id||"");t?.forEach(t=>{t&&-1!==i.indexOf(t.id)?(t.graphic&&t.graphic.hide(),t.dataLabel&&t.dataLabel.hide()):t?.destroy?.()})}function q(t){let e=!1;return!!C(t)&&(b(t,t=>{if(e=!0,!x(t)||!t.length){e=!1;return}for(let i=0;i<t.length;i++)if(!C(t[i])||!t[i].x||!t[i].y){e=!1;return}}),e)}function U(t){let[e,i]=t.key.split(":").map(parseFloat),s=t.gridSize,a=t.groupedData,r=t.defaultRadius,o=t.clusterRadius,n=i*s,l=e*s,u=K(this,t),p=[],h=this.options.cluster?.marker,d=this.options.cluster?.zones,m=this.getGridOffset(),g=u.x,x=u.y,y=0,C=0,k,I,b,M,S,w,A,P,X,Y,L,z;g-=m.plotLeft,x-=m.plotTop;for(let a=1;a<5;a++)for(A=0,b=a%2?-1:1,M=a<3?-1:1,S=Math.floor((g+b*o)/s),z=[(w=Math.floor((x+M*o)/s))+":"+S,w+":"+i,e+":"+S];A<z.length;A++)-1===p.indexOf(z[A])&&z[A]!==t.key&&p.push(z[A]);for(let t of p)if(a[t]){a[t].posX||(Y=O(a[t]),a[t].posX=Y.x,a[t].posY=Y.y);let u=K(this,{x:a[t].posX||0,y:a[t].posY||0});if(k=u.x-m.plotLeft,I=u.y-m.plotTop,[X,P]=t.split(":").map(parseFloat),d){y=a[t].length;for(let t=0;t<d.length;t++)y>=d[t].from&&y<=d[t].to&&(C=f(d[t].marker?.radius)?d[t].marker.radius||0:h?.radius?h.radius:c.marker.radius??0)}a[t].length>1&&0===C&&h?.radius?C=h.radius:1===a[t].length&&(C=r),L=o+C,C=0,P!==i&&Math.abs(g-k)<L&&(g=P-i<0?n+o:n+s-o),X!==e&&Math.abs(x-I)<L&&(x=X-e<0?l+o:l+s-o)}let D=V(this,{x:g+m.plotLeft,y:x+m.plotTop});return a[t.key].posX=D.x,a[t.key].posY=D.y,D}function K(t,e){let{chart:i,xAxis:s,yAxis:a}=t;return i.mapView?i.mapView.projectedUnitsToPixels(e):{x:s?s.toPixels(e.x):0,y:a?a.toPixels(e.y):0}}let $=function(t,e){let i=e.prototype;!i.markerClusterAlgorithms&&(A=i.generatePoints,i.markerClusterAlgorithms=w,i.animateClusterPoint=E,i.destroyClusteredData=j,i.generatePoints=G,i.getClusterDistancesFromPoint=N,i.getClusteredData=F,i.getGridOffset=W,i.getPointsState=_,i.getRealExtremes=Z,i.getScaledGridSize=B,i.hideClusteredData=H,i.isValidGroupedDataObject=q,i.preventClusterCollisions=U,m(e,"destroy",i.destroyClusteredData),t.plotOptions&&(t.plotOptions.series=I(t.plotOptions.series,r)))},{animObject:J}=a(),{defaultOptions:Q}=a(),{composed:tt}=a(),{addEvent:te,defined:ti,error:ts,isFunction:ta,merge:tr,pushUnique:to,syncTimeout:tn}=a();function tl(){let t=this.chart,e=0;for(let i of t.series)i.markerClusterInfo&&(e=J((i.options.cluster||{}).animation).duration||0);tn(()=>{t.tooltip&&t.tooltip.destroy()},e)}function tu(){for(let t of this.series||[])if(t.markerClusterInfo){let e=t.options.cluster,i=((t.markerClusterInfo||{}).pointsState||{}).oldState;if((e||{}).animation&&t.markerClusterInfo&&0===(t.chart.pointer?.pinchDown||[]).length&&"pan"!==((t.xAxis||{}).eventArgs||{}).trigger&&i&&Object.keys(i).length){for(let e of t.markerClusterInfo.clusters)t.animateClusterPoint(e);for(let e of t.markerClusterInfo.noise)t.animateClusterPoint(e)}}}function tp(t){let e=(((t.point||t.target).series.options.cluster||{}).events||{}).drillToCluster;ta(e)&&e.call(this,t)}function th(){if(this.dataGroup)return ts("Highcharts marker-clusters module: Running `Point.update` when point belongs to clustered series is not supported.",!1,this.series.chart),!1}function td(){let t=(this.options.cluster||{}).drillToCluster;if(this.markerClusterInfo&&this.markerClusterInfo.clusters)for(let e of this.markerClusterInfo.clusters)e.point&&e.point.graphic&&(e.point.graphic.addClass("highcharts-cluster-point"),t&&e.point&&(e.point.graphic.css({cursor:"pointer"}),e.point.dataLabel&&e.point.dataLabel.css({cursor:"pointer"})),ti(e.clusterZone)&&e.point.graphic.addClass(e.clusterZoneClassName||"highcharts-cluster-zone-"+e.clusterZone.zoneIndex))}function tc(e,i,s,a){let r=s/2,o=a/2,n=t.arc(e+r,i+o,r-4,o-4,{start:.5*Math.PI,end:2.5*Math.PI,open:!1}),l=t.arc(e+r,i+o,r-3,o-3,{start:.5*Math.PI,end:2.5*Math.PI,innerR:r-2,open:!1});return t.arc(e+r,i+o,r-1,o-1,{start:.5*Math.PI,end:2.5*Math.PI,innerR:r,open:!1}).concat(l,n)}(Q.plotOptions||{}).series=tr((Q.plotOptions||{}).series,r);let tm=a();({compose:function(t,e,i,s){if(to(tt,"MarkerClusters")){let a=s.prototype.pointClass,{scatter:r}=s.types;te(t,"setExtremes",tl),te(e,"render",tu),te(a,"drillToCluster",tp),te(a,"update",th),te(s,"afterRender",td),r&&$(i,r)}}}).compose(tm.Axis,tm.Chart,tm.defaultOptions,tm.Series),({compose:function(e){(t=e.prototype.symbols).cluster=tc}}).compose(tm.SVGRenderer);let tf=a();export{tf as default};