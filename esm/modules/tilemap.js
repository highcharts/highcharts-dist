/**
 * Highmaps JS v12.4.0 (2025-09-04)
 * @module highcharts/modules/tilemap
 * @requires highcharts
 * @requires highcharts/modules/map
 *
 * Tilemap module
 *
 * (c) 2010-2025 Highsoft AS
 *
 * License: www.highcharts.com/license
 */import*as t from"../highcharts.js";import"./map.js";var e,i={};i.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return i.d(e,{a:e}),e},i.d=(t,e)=>{for(var s in e)i.o(e,s)&&!i.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:e[s]})},i.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let s=t.default;var a=i.n(s);i.d({},{});let o=t.default.SeriesRegistry;var n=i.n(o);let l=t.default.Color,{parse:r}=i.n(l)(),{addEvent:h,extend:p,merge:d,pick:c,splat:u}=a();!function(t){let e;function i(){let{userOptions:t}=this;this.colorAxis=[],t.colorAxis&&(t.colorAxis=u(t.colorAxis),t.colorAxis.map(t=>new e(this,t)))}function s(t){let e=this.chart.colorAxis||[],i=e=>{let i=t.allItems.indexOf(e);-1!==i&&(this.destroyItem(t.allItems[i]),t.allItems.splice(i,1))},s=[],a,o;for(e.forEach(function(t){a=t.options,a?.showInLegend&&(a.dataClasses&&a.visible?s=s.concat(t.getDataClassLegendSymbols()):a.visible&&s.push(t),t.series.forEach(function(t){(!t.options.showInLegend||a.dataClasses)&&("point"===t.options.legendType?t.points.forEach(function(t){i(t)}):i(t))}))}),o=s.length;o--;)t.allItems.unshift(s[o])}function a(t){t.visible&&t.item.legendColor&&t.item.legendItem.symbol.attr({fill:t.item.legendColor})}function o(t){this.chart.colorAxis?.forEach(e=>{e.update({},t.redraw)})}function n(){(this.chart.colorAxis?.length||this.colorAttribs)&&this.translateColors()}function l(){let t=this.axisTypes;t?-1===t.indexOf("colorAxis")&&t.push("colorAxis"):this.axisTypes=["colorAxis"]}function x(t){let e=this,i=t?"show":"hide";e.visible=e.options.visible=!!t,["graphic","dataLabel"].forEach(function(t){e[t]&&e[t][i]()}),this.series.buildKDTree()}function g(){let t=this,e=this.getPointsCollection(),i=this.options.nullColor,s=this.colorAxis,a=this.colorKey;e.forEach(e=>{let o=e.getNestedProperty(a),n=e.options.color||(e.isNull||null===e.value?i:s&&void 0!==o?s.toColor(o,e):e.color||t.color);n&&e.color!==n&&(e.color=n,"point"===t.options.legendType&&e.legendItem&&e.legendItem.label&&t.chart.legend.colorizeItem(e,e.visible))})}function f(){this.elem.attr("fill",r(this.start).tweenTo(r(this.end),this.pos),void 0,!0)}function y(){this.elem.attr("stroke",r(this.start).tweenTo(r(this.end),this.pos),void 0,!0)}t.compose=function(t,r,u,m,b){let A=r.prototype,P=u.prototype,M=b.prototype;A.collectionsWithUpdate.includes("colorAxis")||(e=t,A.collectionsWithUpdate.push("colorAxis"),A.collectionsWithInit.colorAxis=[A.addColorAxis],h(r,"afterCreateAxes",i),function(t){let i=t.prototype.createAxis;t.prototype.createAxis=function(t,s){if("colorAxis"!==t)return i.apply(this,arguments);let a=new e(this,d(s.axis,{index:this[t].length,isX:!1}));return this.isDirtyLegend=!0,this.axes.forEach(t=>{t.series=[]}),this.series.forEach(t=>{t.bindAxes(),t.isDirtyData=!0}),c(s.redraw,!0)&&this.redraw(s.animation),a}}(r),P.fillSetter=f,P.strokeSetter=y,h(m,"afterGetAllItems",s),h(m,"afterColorizeItem",a),h(m,"afterUpdate",o),p(M,{optionalAxis:"colorAxis",translateColors:g}),p(M.pointClass.prototype,{setVisible:x}),h(b,"afterTranslate",n,{order:1}),h(b,"bindAxes",l))},t.pointSetVisible=x}(e||(e={}));let x=e,{series:{prototype:{pointClass:g}},seriesTypes:{heatmap:{prototype:{pointClass:f}}}}=n(),{extend:y}=a();class m extends f{haloPath(){return this.series.tileShape.haloPath.apply(this,arguments)}}y(m.prototype,{setState:g.prototype.setState,setVisible:x.pointSetVisible});let{noop:b}=a(),{heatmap:A,scatter:P}=n().seriesTypes,{clamp:M,pick:L}=a();function v(t,e,i){let s=t.options;return{xPad:-((s.colsize||1)/e),yPad:-((s.rowsize||1)/i)}}let S={hexagon:{alignDataLabel:P.prototype.alignDataLabel,getSeriesPadding:function(t){return v(t,3,2)},haloPath:function(t){if(!t)return[];let e=this.tileEdges;return[["M",e.x2-t,e.y1+t],["L",e.x3+t,e.y1+t],["L",e.x4+1.5*t,e.y2],["L",e.x3+t,e.y3-t],["L",e.x2-t,e.y3-t],["L",e.x1-1.5*t,e.y2],["Z"]]},translate:function(){let t,e=this.options,i=this.xAxis,s=this.yAxis,a=e.pointPadding||0,o=(e.colsize||1)/3,n=(e.rowsize||1)/2;for(let e of(this.generatePoints(),this.points)){let l=M(Math.floor(i.len-i.translate(e.x-2*o,0,1,0,1)),-i.len,2*i.len),r=M(Math.floor(i.len-i.translate(e.x-o,0,1,0,1)),-i.len,2*i.len),h=M(Math.floor(i.len-i.translate(e.x+o,0,1,0,1)),-i.len,2*i.len),p=M(Math.floor(i.len-i.translate(e.x+2*o,0,1,0,1)),-i.len,2*i.len),d=M(Math.floor(s.translate(e.y-n,0,1,0,1)),-s.len,2*s.len),c=M(Math.floor(s.translate(e.y,0,1,0,1)),-s.len,2*s.len),u=M(Math.floor(s.translate(e.y+n,0,1,0,1)),-s.len,2*s.len),x=e.pointPadding??a,g=x*Math.abs(r-l)/Math.abs(u-c),f=i.reversed?-g:g,y=i.reversed?-x:x,m=s.reversed?-x:x;e.x%2&&(t=t||Math.round(Math.abs(u-d)/2)*(s.reversed?-1:1),d+=t,c+=t,u+=t),e.plotX=e.clientX=(r+h)/2,e.plotY=c,e.tileEdges={x1:l+=f+y,x2:r+=y,x3:h-=y,x4:p-=f+y,y1:d-=m,y2:c,y3:u+=m},e.shapeType="path",e.shapeArgs={d:[["M",r,d],["L",h,d],["L",p,c],["L",h,u],["L",r,u],["L",l,c],["Z"]]}}this.translateColors()}},diamond:{alignDataLabel:P.prototype.alignDataLabel,getSeriesPadding:function(t){return v(t,2,2)},haloPath:function(t){if(!t)return[];let e=this.tileEdges;return[["M",e.x2,e.y1+t],["L",e.x3+t,e.y2],["L",e.x2,e.y3-t],["L",e.x1-t,e.y2],["Z"]]},translate:function(){let t,e=this.options,i=this.xAxis,s=this.yAxis,a=e.pointPadding||0,o=e.colsize||1,n=(e.rowsize||1)/2;for(let e of(this.generatePoints(),this.points)){let l=M(Math.round(i.len-i.translate(e.x-o,0,1,0,0)),-i.len,2*i.len),r=M(Math.round(i.len-i.translate(e.x+o,0,1,0,0)),-i.len,2*i.len),h=M(Math.round(s.translate(e.y-n,0,1,0,0)),-s.len,2*s.len),p=M(Math.round(s.translate(e.y,0,1,0,0)),-s.len,2*s.len),d=M(Math.round(s.translate(e.y+n,0,1,0,0)),-s.len,2*s.len),c=M(Math.round(i.len-i.translate(e.x,0,1,0,0)),-i.len,2*i.len),u=L(e.pointPadding,a),x=u*Math.abs(c-l)/Math.abs(d-p),g=i.reversed?-x:x,f=s.reversed?-u:u;e.x%2&&(t=Math.abs(d-h)/2*(s.reversed?-1:1),h+=t,p+=t,d+=t),e.plotX=e.clientX=c,e.plotY=p,e.tileEdges={x1:l+=g,x2:c,x3:r-=g,y1:h-=f,y2:p,y3:d+=f},e.shapeType="path",e.shapeArgs={d:[["M",c,h],["L",r,p],["L",c,d],["L",l,p],["Z"]]}}this.translateColors()}},circle:{alignDataLabel:P.prototype.alignDataLabel,getSeriesPadding:function(t){return v(t,2,2)},haloPath:function(t){return P.prototype.pointClass.prototype.haloPath.call(this,t+(t&&this.radius))},translate:function(){let t=this.options,e=this.xAxis,i=this.yAxis,s=t.pointPadding||0,a=(t.rowsize||1)/2,o=t.colsize||1,n,l,r,h,p=!1;for(let t of(this.generatePoints(),this.points)){let d=M(Math.round(e.len-e.translate(t.x,0,1,0,0)),-e.len,2*e.len),c=s,u=!1,x=M(Math.round(i.translate(t.y,0,1,0,0)),-i.len,2*i.len);void 0!==t.pointPadding&&(c=t.pointPadding,u=!0,p=!0),(!h||p)&&(r=Math.floor(Math.sqrt((n=Math.abs(M(Math.floor(e.len-e.translate(t.x+o,0,1,0,0)),-e.len,2*e.len)-d))*n+(l=Math.abs(M(Math.floor(i.translate(t.y+a,0,1,0,0)),-i.len,2*i.len)-x))*l)/2),h=Math.min(n,r,l)-c,p&&!u&&(p=!1)),t.x%2&&(x+=l*(i.reversed?-1:1)),t.plotX=t.clientX=d,t.plotY=x,t.radius=h,t.shapeType="circle",t.shapeArgs={x:d,y:x,r:h}}this.translateColors()}},square:{alignDataLabel:A.prototype.alignDataLabel,translate:A.prototype.translate,getSeriesPadding:b,haloPath:A.prototype.pointClass.prototype.haloPath}},{composed:C,noop:T}=a(),{column:w,heatmap:D,scatter:I}=n().seriesTypes,{addEvent:E,extend:z,merge:O,pushUnique:X}=a();function F(){if(this.recomputingForTilemap||"colorAxis"===this.coll)return;let t=this,e=t.series.map(function(e){return e.getSeriesPixelPadding&&e.getSeriesPixelPadding(t)}).reduce(function(t,e){return(t&&t.padding)>(e&&e.padding)?t:e},void 0)||{padding:0,axisLengthFactor:1},i=Math.round(e.padding*e.axisLengthFactor);e.padding&&(t.len-=i,t.recomputingForTilemap=!0,t.setAxisTranslation(),delete t.recomputingForTilemap,t.minPixelPadding+=e.padding,t.len+=i)}class k extends D{static compose(t){X(C,"TilemapSeries")&&E(t,"afterSetAxisTranslation",F)}alignDataLabel(){return this.tileShape.alignDataLabel.apply(this,arguments)}drawPoints(){for(let t of(w.prototype.drawPoints.call(this),this.points))t.graphic&&t.graphic[this.chart.styledMode?"css":"animate"](this.colorAttribs(t))}getSeriesPixelPadding(t){let e=t.isXAxis,i=this.tileShape.getSeriesPadding(this);if(!i)return{padding:0,axisLengthFactor:1};let s=Math.round(t.translate(e?2*i.xPad:i.yPad,0,1,0,1)),a=Math.round(t.translate(e?i.xPad:0,0,1,0,1));return{padding:(t.single?Math.abs(s-a)/2:Math.abs(s-a))||0,axisLengthFactor:e?2:1.1}}setOptions(){let t=super.setOptions.apply(this,arguments);return this.tileShape=S[t.tileShape],t}translate(){return this.tileShape.translate.apply(this,arguments)}}k.defaultOptions=O(D.defaultOptions,{marker:null,states:{hover:{halo:{enabled:!0,size:2,opacity:.5,attributes:{zIndex:3}}}},pointPadding:2,tileShape:"hexagon"}),z(k.prototype,{getSymbol:T,markerAttribs:I.prototype.markerAttribs,pointAttribs:w.prototype.pointAttribs,pointClass:m}),n().registerSeriesType("tilemap",k);let j=a();k.compose(j.Axis);let V=a();export{V as default};