/**
 * Highstock JS v12.3.0 (2025-06-21)
 * @module highcharts/indicators/macd
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2025 Sebastian Bochan
 *
 * License: www.highcharts.com/license
 */import*as s from"../highcharts.js";import"../modules/stock.js";var o={};o.n=s=>{var e=s&&s.__esModule?()=>s.default:()=>s;return o.d(e,{a:e}),e},o.d=(s,e)=>{for(var t in e)o.o(e,t)&&!o.o(s,t)&&Object.defineProperty(s,t,{enumerable:!0,get:e[t]})},o.o=(s,o)=>Object.prototype.hasOwnProperty.call(s,o);let e=s.default;var t=o.n(e);o.d({},{});let i=s.default.SeriesRegistry;var n=o.n(i);let{noop:l}=t(),{column:r,sma:a}=n().seriesTypes,{extend:p,correctFloat:h,defined:d,merge:g}=t();class c extends a{init(){n().seriesTypes.sma.prototype.init.apply(this,arguments);let s=this.color;this.options&&(d(this.colorIndex)&&(this.options.signalLine&&this.options.signalLine.styles&&!this.options.signalLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.signalLine.styles.lineColor=this.color),this.options.macdLine&&this.options.macdLine.styles&&!this.options.macdLine.styles.lineColor&&(this.options.colorIndex=this.colorIndex+1,this.getCyclic("color",void 0,this.chart.options.colors),this.options.macdLine.styles.lineColor=this.color)),this.macdZones={zones:this.options.macdLine.zones,startIndex:0},this.signalZones={zones:this.macdZones.zones.concat(this.options.signalLine.zones),startIndex:this.macdZones.zones.length}),this.color=s}toYData(s){return[s.y,s.signal,s.MACD]}translate(){let s=this,o=["plotSignal","plotMACD"];t().seriesTypes.column.prototype.translate.apply(s),s.points.forEach(function(e){[e.signal,e.MACD].forEach(function(t,i){null!==t&&(e[o[i]]=s.yAxis.toPixels(t,!0))})})}destroy(){this.graph=null,this.graphmacd=this.graphmacd&&this.graphmacd.destroy(),this.graphsignal=this.graphsignal&&this.graphsignal.destroy(),n().seriesTypes.sma.prototype.destroy.apply(this,arguments)}drawGraph(){let s=this,o=s.points,e=s.options,t=s.zones,i={options:{gapSize:e.gapSize}},l=[[],[]],r,a=o.length;for(;a--;)d((r=o[a]).plotMACD)&&l[0].push({plotX:r.plotX,plotY:r.plotMACD,isNull:!d(r.plotMACD)}),d(r.plotSignal)&&l[1].push({plotX:r.plotX,plotY:r.plotSignal,isNull:!d(r.plotMACD)});["macd","signal"].forEach((o,t)=>{s.points=l[t],s.options=g(e[`${o}Line`]?.styles||{},i),s.graph=s[`graph${o}`],s.zones=(s[`${o}Zones`].zones||[]).slice(s[`${o}Zones`].startIndex||0),n().seriesTypes.sma.prototype.drawGraph.call(s),s[`graph${o}`]=s.graph}),s.points=o,s.options=e,s.zones=t}applyZones(){let s=this.zones;this.zones=this.signalZones.zones,n().seriesTypes.sma.prototype.applyZones.call(this),this.graphmacd&&this.options.macdLine.zones.length&&this.graphmacd.hide(),this.zones=s}getValues(s,o){let e=o.longPeriod-o.shortPeriod,t=[],i=[],l=[],r,a,p,g=0,c=[];if(!(s.xData.length<o.longPeriod+o.signalPeriod)){for(p=0,r=n().seriesTypes.ema.prototype.getValues(s,{period:o.shortPeriod,index:o.index}),a=n().seriesTypes.ema.prototype.getValues(s,{period:o.longPeriod,index:o.index}),r=r.values,a=a.values;p<=r.length;p++)d(a[p])&&d(a[p][1])&&d(r[p+e])&&d(r[p+e][0])&&t.push([r[p+e][0],0,null,r[p+e][1]-a[p][1]]);for(p=0;p<t.length;p++)i.push(t[p][0]),l.push([0,null,t[p][3]]);for(p=0,c=(c=n().seriesTypes.ema.prototype.getValues({xData:i,yData:l},{period:o.signalPeriod,index:2})).values;p<t.length;p++)t[p][0]>=c[0][0]&&(t[p][2]=c[g][1],l[p]=[0,c[g][1],t[p][3]],null===t[p][3]?(t[p][1]=0,l[p][0]=0):(t[p][1]=h(t[p][3]-c[g][1]),l[p][0]=h(t[p][3]-c[g][1])),g++);return{values:t,xData:i,yData:l}}}}c.defaultOptions=g(a.defaultOptions,{params:{shortPeriod:12,longPeriod:26,signalPeriod:9,period:26},signalLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},macdLine:{zones:[],styles:{lineWidth:1,lineColor:void 0}},threshold:0,groupPadding:.1,pointPadding:.1,crisp:!1,states:{hover:{halo:{size:0}}},tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span> <b> {series.name}</b><br/>Value: {point.MACD}<br/>Signal: {point.signal}<br/>Histogram: {point.y}<br/>'},dataGrouping:{approximation:"averages"},minPointLength:0}),p(c.prototype,{nameComponents:["longPeriod","shortPeriod","signalPeriod"],pointArrayMap:["y","signal","MACD"],parallelArrays:["x","y","signal","MACD"],pointValKey:"y",markerAttribs:l,getColumnMetrics:t().seriesTypes.column.prototype.getColumnMetrics,crispCol:t().seriesTypes.column.prototype.crispCol,drawPoints:t().seriesTypes.column.prototype.drawPoints}),n().registerSeriesType("macd",c);let y=t();export{y as default};