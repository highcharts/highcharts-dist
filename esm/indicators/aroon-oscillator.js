/**
 * Highstock JS v12.3.0 (2025-06-21)
 * @module highcharts/indicators/aroon-oscillator
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2025 Wojciech Chmiel
 *
 * License: www.highcharts.com/license
 */import*as t from"../highcharts.js";import"../modules/stock.js";var e,a={};a.n=t=>{var e=t&&t.__esModule?()=>t.default:()=>t;return a.d(e,{a:e}),e},a.d=(t,e)=>{for(var o in e)a.o(e,o)&&!a.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:e[o]})},a.o=(t,e)=>Object.prototype.hasOwnProperty.call(t,e);let o=t.default;var r=a.n(o);a.d({},{});let i=t.default.SeriesRegistry;var s=a.n(i);let{sma:{prototype:l}}=s().seriesTypes,{defined:n,error:p,merge:h}=r();!function(t){let e=["bottomLine"],a=["top","bottom"],o=["top"];function r(t){return"plot"+t.charAt(0).toUpperCase()+t.slice(1)}function i(t,e){let a=[];return(t.pointArrayMap||[]).forEach(t=>{t!==e&&a.push(r(t))}),a}function s(){let t=this,e=t.pointValKey,a=t.linesApiNames,o=t.areaLinesNames,s=t.points,c=t.options,u=t.graph,f={options:{gapSize:c.gapSize}},y=[],d=i(t,e),g=s.length,m;if(d.forEach((t,e)=>{for(y[e]=[];g--;)m=s[g],y[e].push({x:m.x,plotX:m.plotX,plotY:m[t],isNull:!n(m[t])});g=s.length}),t.userOptions.fillColor&&o.length){let e=y[d.indexOf(r(o[0]))],a=1===o.length?s:y[d.indexOf(r(o[1]))],i=t.color;t.points=a,t.nextPoints=e,t.color=t.userOptions.fillColor,t.options=h(s,f),t.graph=t.area,t.fillGraph=!0,l.drawGraph.call(t),t.area=t.graph,delete t.nextPoints,delete t.fillGraph,t.color=i}a.forEach((e,a)=>{y[a]?(t.points=y[a],c[e]?t.options=h(c[e].styles,f):p('Error: "There is no '+e+' in DOCS options declared. Check if linesApiNames are consistent with your DOCS line names."'),t.graph=t["graph"+e],l.drawGraph.call(t),t["graph"+e]=t.graph):p('Error: "'+e+" doesn't have equivalent in pointArrayMap. To many elements in linesApiNames relative to pointArrayMap.\"")}),t.points=s,t.options=c,t.graph=u,l.drawGraph.call(t)}function c(t){let e,a=[],o=[];if(t=t||this.points,this.fillGraph&&this.nextPoints){if((e=l.getGraphPath.call(this,this.nextPoints))&&e.length){e[0][0]="L",a=l.getGraphPath.call(this,t),o=e.slice(0,a.length);for(let t=o.length-1;t>=0;t--)a.push(o[t])}}else a=l.getGraphPath.apply(this,arguments);return a}function u(t){let e=[];return(this.pointArrayMap||[]).forEach(a=>{e.push(t[a])}),e}function f(){let t=this.pointArrayMap,e=[],a;e=i(this),l.translate.apply(this,arguments),this.points.forEach(o=>{t.forEach((t,r)=>{a=o[t],this.dataModify&&(a=this.dataModify.modifyValue(a)),null!==a&&(o[e[r]]=this.yAxis.toPixels(a,!0))})})}t.compose=function(t){let r=t.prototype;return r.linesApiNames=r.linesApiNames||e.slice(),r.pointArrayMap=r.pointArrayMap||a.slice(),r.pointValKey=r.pointValKey||"top",r.areaLinesNames=r.areaLinesNames||o.slice(),r.drawGraph=s,r.getGraphPath=c,r.toYData=u,r.translate=f,t}}(e||(e={}));let c=e,{aroon:u}=s().seriesTypes,{extend:f,merge:y}=r();class d extends u{getValues(t,e){let a,o,r=[],i=[],s=[],l=super.getValues.call(this,t,e);for(o=0;o<l.yData.length;o++)a=l.yData[o][0]-l.yData[o][1],r.push([l.xData[o],a]),i.push(l.xData[o]),s.push(a);return{values:r,xData:i,yData:s}}}d.defaultOptions=y(u.defaultOptions,{tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span><b> {series.name}</b>: {point.y}'}}),f(d.prototype,{nameBase:"Aroon Oscillator",linesApiNames:[],pointArrayMap:["y"],pointValKey:"y"}),c.compose(u),s().registerSeriesType("aroonoscillator",d);let g=r();export{g as default};