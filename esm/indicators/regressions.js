/**
 * Highstock JS v12.5.0 (2026-01-12)
 * @module highcharts/indicators/regressions
 * @requires highcharts
 * @requires highcharts/modules/stock
 *
 * Indicator series type for Highcharts Stock
 *
 * (c) 2010-2026 Highsoft AS
 * Author: Kamil Kulig
 *
 * A commercial license may be required depending on use.
 * See www.highcharts.com/license
 */import*as e from"../highcharts.js";var t={};t.n=e=>{var r=e&&e.__esModule?()=>e.default:()=>e;return t.d(r,{a:r}),r},t.d=(e,r)=>{for(var s in r)t.o(r,s)&&!t.o(e,s)&&Object.defineProperty(e,s,{enumerable:!0,get:r[s]})},t.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t);let r=e.default;var s=t.n(r);let n=e.default.SeriesRegistry;var a=t.n(n);let{sma:i}=a().seriesTypes,{isArray:o,extend:l,merge:p}=s();class g extends i{getRegressionLineParameters(e,t){let r=this.options.params.index,s=function(e,t){return o(e)?e[t]:e},n=e.reduce(function(e,t){return t+e},0),a=t.reduce(function(e,t){return s(t,r)+e},0),i=n/e.length,l=a/t.length,p,g,u=0,d=0;for(g=0;g<e.length;g++)u+=(p=e[g]-i)*(s(t[g],r)-l),d+=Math.pow(p,2);let c=d?u/d:0;return{slope:c,intercept:l-c*i}}getEndPointY(e,t){return e.slope*t+e.intercept}transformXData(e,t){let r=e[0];return e.map(function(e){return(e-r)/t})}findClosestDistance(e){let t,r,s;for(s=1;s<e.length-1;s++)(t=e[s]-e[s-1])>0&&(void 0===r||t<r)&&(r=t);return r}getValues(e,t){let r,s,n,a,i,l,p,g,u,d=e.xData,c=e.yData,f=t.period,h={xData:[],yData:[],values:[]},m=this.options.params.xAxisUnit||this.findClosestDistance(d);for(s=f-1;s<=d.length-1;s++)n=s-f+1,a=s+1,i=d[s],p=d.slice(n,a),g=c.slice(n,a),u=this.transformXData(p,m),r=this.getRegressionLineParameters(u,g),l=this.getEndPointY(r,u[u.length-1]),h.values.push({regressionLineParameters:r,x:i,y:l}),o(h.xData)&&h.xData.push(i),o(h.yData)&&h.yData.push(l);return h}}g.defaultOptions=p(i.defaultOptions,{params:{xAxisUnit:null},tooltip:{valueDecimals:4}}),l(g.prototype,{nameBase:"Linear Regression Indicator"}),a().registerSeriesType("linearRegression",g);let{linearRegression:u}=a().seriesTypes,{extend:d,merge:c}=s();class f extends u{getEndPointY(e){return e.slope}}f.defaultOptions=c(u.defaultOptions),d(f.prototype,{nameBase:"Linear Regression Slope Indicator"}),a().registerSeriesType("linearRegressionSlope",f);let{linearRegression:h}=a().seriesTypes,{extend:m,merge:y}=s();class x extends h{getEndPointY(e){return e.intercept}}x.defaultOptions=y(h.defaultOptions),m(x.prototype,{nameBase:"Linear Regression Intercept Indicator"}),a().registerSeriesType("linearRegressionIntercept",x);let{linearRegression:R}=a().seriesTypes,{extend:D,merge:O}=s();class P extends R{slopeToAngle(e){return 180/Math.PI*Math.atan(e)}getEndPointY(e){return this.slopeToAngle(e.slope)}}P.defaultOptions=O(R.defaultOptions,{tooltip:{pointFormat:'<span style="color:{point.color}">‚óè</span>{series.name}: <b>{point.y}\xb0</b><br/>'}}),D(P.prototype,{nameBase:"Linear Regression Angle Indicator"}),a().registerSeriesType("linearRegressionAngle",P);let T=s();export{T as default};